<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>r-type: Registry Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">r-type<span id="projectnumber">&#160;0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classRegistry-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Registry Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classRegistry.html" title="The Registry class is the core of the ECS (Entity-Component-System) architecture.">Registry</a> class is the core of the ECS (Entity-Component-System) architecture.  
 <a href="classRegistry.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Registry_8hpp_source.html">Registry.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa3c7728231c60cf0e6742d693aa50bbf" id="r_aa3c7728231c60cf0e6742d693aa50bbf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptcomponent.html">component</a> Component&gt; </td></tr>
<tr class="memitem:aa3c7728231c60cf0e6742d693aa50bbf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSparseArray.html">SparseArray</a>&lt; Component &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRegistry.html#aa3c7728231c60cf0e6742d693aa50bbf">register_component</a> (std::string const &amp;string_id)</td></tr>
<tr class="memdesc:aa3c7728231c60cf0e6742d693aa50bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a bytable component type with a string identifier.  <br /></td></tr>
<tr class="separator:aa3c7728231c60cf0e6742d693aa50bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ff3522b765d882b46262ad345db07b" id="r_ab8ff3522b765d882b46262ad345db07b"><td class="memTemplParams" colspan="2">template&lt;class Component &gt; </td></tr>
<tr class="memitem:ab8ff3522b765d882b46262ad345db07b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSparseArray.html">SparseArray</a>&lt; Component &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRegistry.html#ab8ff3522b765d882b46262ad345db07b">get_components</a> ()</td></tr>
<tr class="memdesc:ab8ff3522b765d882b46262ad345db07b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the components object.  <br /></td></tr>
<tr class="separator:ab8ff3522b765d882b46262ad345db07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdce4af207b1240a6c10b83ad66cc4b4" id="r_afdce4af207b1240a6c10b83ad66cc4b4"><td class="memTemplParams" colspan="2">template&lt;class Component &gt; </td></tr>
<tr class="memitem:afdce4af207b1240a6c10b83ad66cc4b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSparseArray.html">SparseArray</a>&lt; Component &gt; const &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRegistry.html#afdce4af207b1240a6c10b83ad66cc4b4">get_components</a> () const</td></tr>
<tr class="separator:afdce4af207b1240a6c10b83ad66cc4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebe63c781a345ce210cfcfa5da3fcae" id="r_a0ebe63c781a345ce210cfcfa5da3fcae"><td class="memTemplParams" colspan="2">template&lt;class... Component&gt; </td></tr>
<tr class="memitem:a0ebe63c781a345ce210cfcfa5da3fcae"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRegistry.html#a0ebe63c781a345ce210cfcfa5da3fcae">has_component</a> (const Entity &amp;e) const</td></tr>
<tr class="memdesc:a0ebe63c781a345ce210cfcfa5da3fcae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an entity has all specified components.  <br /></td></tr>
<tr class="separator:a0ebe63c781a345ce210cfcfa5da3fcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e982e5c9b7207dce933e2210b4cce4b" id="r_a2e982e5c9b7207dce933e2210b4cce4b"><td class="memItemLeft" align="right" valign="top">Entity&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#a2e982e5c9b7207dce933e2210b4cce4b">spawn_entity</a> ()</td></tr>
<tr class="memdesc:a2e982e5c9b7207dce933e2210b4cce4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns a new entity.  <br /></td></tr>
<tr class="separator:a2e982e5c9b7207dce933e2210b4cce4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8e76e4f67a4e33dd7273d065d6be7a" id="r_a9f8e76e4f67a4e33dd7273d065d6be7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#a9f8e76e4f67a4e33dd7273d065d6be7a">kill_entity</a> (Entity const &amp;e)</td></tr>
<tr class="memdesc:a9f8e76e4f67a4e33dd7273d065d6be7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks an entity for deletion.  <br /></td></tr>
<tr class="separator:a9f8e76e4f67a4e33dd7273d065d6be7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b33f8cf1890733209cf94c0d15da4f" id="r_ac4b33f8cf1890733209cf94c0d15da4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#ac4b33f8cf1890733209cf94c0d15da4f">is_entity_dying</a> (Entity const &amp;e) const</td></tr>
<tr class="memdesc:ac4b33f8cf1890733209cf94c0d15da4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an entity is marked for deletion.  <br /></td></tr>
<tr class="separator:ac4b33f8cf1890733209cf94c0d15da4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf00a9ea3b232b551de02598cbc7756" id="r_a2cf00a9ea3b232b551de02598cbc7756"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#a2cf00a9ea3b232b551de02598cbc7756">process_entity_deletions</a> ()</td></tr>
<tr class="memdesc:a2cf00a9ea3b232b551de02598cbc7756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all entities marked for killing.  <br /></td></tr>
<tr class="separator:a2cf00a9ea3b232b551de02598cbc7756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9990d86dfe7f90e314f8e93773b307d4" id="r_a9990d86dfe7f90e314f8e93773b307d4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptcomponent.html">component</a> Component&gt; </td></tr>
<tr class="memitem:a9990d86dfe7f90e314f8e93773b307d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSparseArray.html">SparseArray</a>&lt; Component &gt;::Ref&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRegistry.html#a9990d86dfe7f90e314f8e93773b307d4">add_component</a> (Entity const &amp;to, Component &amp;&amp;c)</td></tr>
<tr class="memdesc:a9990d86dfe7f90e314f8e93773b307d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a component to an entity by moving.  <br /></td></tr>
<tr class="separator:a9990d86dfe7f90e314f8e93773b307d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedaff3e905a52a1945250cd16ffbb5fb" id="r_aedaff3e905a52a1945250cd16ffbb5fb"><td class="memTemplParams" colspan="2">template&lt;typename Component , typename... Params&gt; </td></tr>
<tr class="memitem:aedaff3e905a52a1945250cd16ffbb5fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSparseArray.html">SparseArray</a>&lt; Component &gt;::Ref&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRegistry.html#aedaff3e905a52a1945250cd16ffbb5fb">emplace_component</a> (Entity const &amp;to, Params &amp;&amp;... p)</td></tr>
<tr class="memdesc:aedaff3e905a52a1945250cd16ffbb5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a component in-place on an entity.  <br /></td></tr>
<tr class="separator:aedaff3e905a52a1945250cd16ffbb5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e78bd26f93b8cf996f457389c422f3" id="r_a02e78bd26f93b8cf996f457389c422f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#a02e78bd26f93b8cf996f457389c422f3">emplace_component</a> (Entity const &amp;to, std::string const &amp;string_id, <a class="el" href="Byte_8hpp.html#ae5dac5ad63f62fe37b5a8cfd8f269493">ByteArray</a> const &amp;bytes)</td></tr>
<tr class="memdesc:a02e78bd26f93b8cf996f457389c422f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a component from binary data by string ID.  <br /></td></tr>
<tr class="separator:a02e78bd26f93b8cf996f457389c422f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae83c694e0e30125b850edcc343406b76" id="r_ae83c694e0e30125b850edcc343406b76"><td class="memTemplParams" colspan="2">template&lt;typename Component &gt; </td></tr>
<tr class="memitem:ae83c694e0e30125b850edcc343406b76"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRegistry.html#ae83c694e0e30125b850edcc343406b76">remove_component</a> (Entity const &amp;from)</td></tr>
<tr class="memdesc:ae83c694e0e30125b850edcc343406b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a component from an entity.  <br /></td></tr>
<tr class="separator:ae83c694e0e30125b850edcc343406b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1a7222875fdfa2859b6470a741b66e" id="r_aee1a7222875fdfa2859b6470a741b66e"><td class="memTemplParams" colspan="2">template&lt;class... Components, typename Function &gt; </td></tr>
<tr class="memitem:aee1a7222875fdfa2859b6470a741b66e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRegistry.html#aee1a7222875fdfa2859b6470a741b66e">add_system</a> (Function &amp;&amp;f, std::size_t priority=0)</td></tr>
<tr class="memdesc:aee1a7222875fdfa2859b6470a741b66e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a system that operates on specified components.  <br /></td></tr>
<tr class="separator:aee1a7222875fdfa2859b6470a741b66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae484ce9b1fdb58e76997409a74227701" id="r_ae484ce9b1fdb58e76997409a74227701"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#ae484ce9b1fdb58e76997409a74227701">run_systems</a> (<a class="el" href="classEventManager.html">EventManager</a> &amp;)</td></tr>
<tr class="memdesc:ae484ce9b1fdb58e76997409a74227701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a system function to run every frame.  <br /></td></tr>
<tr class="separator:ae484ce9b1fdb58e76997409a74227701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99ff1a3c4f750cba3bb80534f4295c4" id="r_ae99ff1a3c4f750cba3bb80534f4295c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#ae99ff1a3c4f750cba3bb80534f4295c4">update_bindings</a> (<a class="el" href="classEventManager.html">EventManager</a> &amp;)</td></tr>
<tr class="memdesc:ae99ff1a3c4f750cba3bb80534f4295c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates all registered dynamic bindings.  <br /></td></tr>
<tr class="separator:ae99ff1a3c4f750cba3bb80534f4295c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529bdf9002188825f7b03f33b2991624" id="r_a529bdf9002188825f7b03f33b2991624"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptcomponent.html">component</a> ComponentType, typename <a class="el" href="IoEvents_8hpp.html#a9479d299e1852e6140dcca1f405868aba21f40778b7db9343a6ca75ec2c41ccce">T</a> &gt; </td></tr>
<tr class="memitem:a529bdf9002188825f7b03f33b2991624"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRegistry.html#a529bdf9002188825f7b03f33b2991624">register_binding</a> (Entity entity, std::string const &amp;field_name, std::string const &amp;source_hook)</td></tr>
<tr class="memdesc:a529bdf9002188825f7b03f33b2991624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a dynamic binding between component fields.  <br /></td></tr>
<tr class="separator:a529bdf9002188825f7b03f33b2991624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44989c0361996ad2c4aefbf4636b664" id="r_ab44989c0361996ad2c4aefbf4636b664"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#ab44989c0361996ad2c4aefbf4636b664">clear_bindings</a> ()</td></tr>
<tr class="memdesc:ab44989c0361996ad2c4aefbf4636b664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all registered bindings.  <br /></td></tr>
<tr class="separator:ab44989c0361996ad2c4aefbf4636b664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfbcd0eed55c7f0d795443ef0f34c855" id="r_adfbcd0eed55c7f0d795443ef0f34c855"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#adfbcd0eed55c7f0d795443ef0f34c855">add_scene</a> (std::string const &amp;scene_name, <a class="el" href="Scenes_8hpp.html#ab0d98f61608665befb0dc9afa0419e19">SceneState</a> state=<a class="el" href="Scenes_8hpp.html#ab0d98f61608665befb0dc9afa0419e19a055c1a591abb0e8cd86dc969727bcc0b">SceneState::DISABLED</a>)</td></tr>
<tr class="memdesc:adfbcd0eed55c7f0d795443ef0f34c855"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structRegister.html">Register</a> a scene with the given name and initial state.  <br /></td></tr>
<tr class="separator:adfbcd0eed55c7f0d795443ef0f34c855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676be837cc2defb394f38b32d664fd30" id="r_a676be837cc2defb394f38b32d664fd30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#a676be837cc2defb394f38b32d664fd30">init_scene_management</a> ()</td></tr>
<tr class="memdesc:a676be837cc2defb394f38b32d664fd30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the scene management system.  <br /></td></tr>
<tr class="separator:a676be837cc2defb394f38b32d664fd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e8c1f487a94aaf2752678d814a942a" id="r_a35e8c1f487a94aaf2752678d814a942a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#a35e8c1f487a94aaf2752678d814a942a">setup_scene_systems</a> ()</td></tr>
<tr class="memdesc:a35e8c1f487a94aaf2752678d814a942a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup automatic scene management systems.  <br /></td></tr>
<tr class="separator:a35e8c1f487a94aaf2752678d814a942a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c9d136cf9da966ef0977d3c698a963" id="r_ad1c9d136cf9da966ef0977d3c698a963"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#ad1c9d136cf9da966ef0977d3c698a963">set_current_scene</a> (std::string const &amp;scene_name)</td></tr>
<tr class="memdesc:ad1c9d136cf9da966ef0977d3c698a963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate a scene, making its entities visible to systems.  <br /></td></tr>
<tr class="separator:ad1c9d136cf9da966ef0977d3c698a963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbf6f291355b03ad61105e4ba682299" id="r_a9fbf6f291355b03ad61105e4ba682299"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#a9fbf6f291355b03ad61105e4ba682299">set_main_scene</a> (std::string const &amp;scene_name)</td></tr>
<tr class="memdesc:a9fbf6f291355b03ad61105e4ba682299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a scene as the MAIN scene.  <br /></td></tr>
<tr class="separator:a9fbf6f291355b03ad61105e4ba682299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936cd3eebe707ee32e2aac62eb079404" id="r_a936cd3eebe707ee32e2aac62eb079404"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#a936cd3eebe707ee32e2aac62eb079404">remove_current_scene</a> (std::string const &amp;scene_name)</td></tr>
<tr class="memdesc:a936cd3eebe707ee32e2aac62eb079404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deactivate a specific scene.  <br /></td></tr>
<tr class="separator:a936cd3eebe707ee32e2aac62eb079404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3aabe22621e394e0e17f2f2b35a59c8" id="r_aa3aabe22621e394e0e17f2f2b35a59c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#aa3aabe22621e394e0e17f2f2b35a59c8">remove_all_scenes</a> ()</td></tr>
<tr class="memdesc:aa3aabe22621e394e0e17f2f2b35a59c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deactivate all scenes.  <br /></td></tr>
<tr class="separator:aa3aabe22621e394e0e17f2f2b35a59c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9eb2723831a87cb5602c43e2b05b0a" id="r_a0b9eb2723831a87cb5602c43e2b05b0a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#a0b9eb2723831a87cb5602c43e2b05b0a">get_current_scene</a> () const</td></tr>
<tr class="memdesc:a0b9eb2723831a87cb5602c43e2b05b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get list of currently active scene names.  <br /></td></tr>
<tr class="separator:a0b9eb2723831a87cb5602c43e2b05b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5df0cfd429a13867b1b490b996c3e8a" id="r_af5df0cfd429a13867b1b490b996c3e8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#af5df0cfd429a13867b1b490b996c3e8a">activate_scene</a> (std::string const &amp;scene_name)</td></tr>
<tr class="memdesc:af5df0cfd429a13867b1b490b996c3e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate a scene.  <br /></td></tr>
<tr class="separator:af5df0cfd429a13867b1b490b996c3e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754e4ccdcfee754754956ba903a86fd2" id="r_a754e4ccdcfee754754956ba903a86fd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#a754e4ccdcfee754754956ba903a86fd2">deactivate_scene</a> (std::string const &amp;scene_name)</td></tr>
<tr class="memdesc:a754e4ccdcfee754754956ba903a86fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deactivate a scene.  <br /></td></tr>
<tr class="separator:a754e4ccdcfee754754956ba903a86fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08789766bb87dcda9159cc2405249b32" id="r_a08789766bb87dcda9159cc2405249b32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#a08789766bb87dcda9159cc2405249b32">deactivate_all_scenes</a> ()</td></tr>
<tr class="memdesc:a08789766bb87dcda9159cc2405249b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deactivate all scenes.  <br /></td></tr>
<tr class="separator:a08789766bb87dcda9159cc2405249b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a2427184d9f6bcfef9a5addfe9511e" id="r_a42a2427184d9f6bcfef9a5addfe9511e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#a42a2427184d9f6bcfef9a5addfe9511e">push_scene</a> (std::string const &amp;scene_name)</td></tr>
<tr class="memdesc:a42a2427184d9f6bcfef9a5addfe9511e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a scene onto the active scene stack.  <br /></td></tr>
<tr class="separator:a42a2427184d9f6bcfef9a5addfe9511e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348496c10466004c5b009e1534202f5d" id="r_a348496c10466004c5b009e1534202f5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#a348496c10466004c5b009e1534202f5d">pop_scene</a> (std::string const &amp;scene_name)</td></tr>
<tr class="memdesc:a348496c10466004c5b009e1534202f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop a scene from the active scene stack.  <br /></td></tr>
<tr class="separator:a348496c10466004c5b009e1534202f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dea4f9463f5e582337406da60b721e6" id="r_a6dea4f9463f5e582337406da60b721e6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#a6dea4f9463f5e582337406da60b721e6">is_scene_active</a> (std::string const &amp;scene_name) const</td></tr>
<tr class="memdesc:a6dea4f9463f5e582337406da60b721e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a scene is currently active.  <br /></td></tr>
<tr class="separator:a6dea4f9463f5e582337406da60b721e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1218f67393c0188a60c152126a1a5e09" id="r_a1218f67393c0188a60c152126a1a5e09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Scenes_8hpp.html#ab0d98f61608665befb0dc9afa0419e19">SceneState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#a1218f67393c0188a60c152126a1a5e09">get_scene_state</a> (std::string const &amp;scene_name) const</td></tr>
<tr class="memdesc:a1218f67393c0188a60c152126a1a5e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the state of a scene.  <br /></td></tr>
<tr class="separator:a1218f67393c0188a60c152126a1a5e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea8e3e48003a382c1391520a5e2dfba" id="r_a4ea8e3e48003a382c1391520a5e2dfba"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; std::string &gt; const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#a4ea8e3e48003a382c1391520a5e2dfba">get_active_scenes_set</a> () const</td></tr>
<tr class="memdesc:a4ea8e3e48003a382c1391520a5e2dfba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the set of active scene names for <a class="el" href="IoEvents_8hpp.html#a9479d299e1852e6140dcca1f405868abaf4b8b7698dfedf5562a7db2bdb07010a">O(1)</a> lookups.  <br /></td></tr>
<tr class="separator:a4ea8e3e48003a382c1391520a5e2dfba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed58f4389647aadc67b76a5db4e20bb3" id="r_aed58f4389647aadc67b76a5db4e20bb3"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, <a class="el" href="Scenes_8hpp.html#ab0d98f61608665befb0dc9afa0419e19">SceneState</a> &gt; const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#aed58f4389647aadc67b76a5db4e20bb3">get_scene_states</a> () const</td></tr>
<tr class="memdesc:aed58f4389647aadc67b76a5db4e20bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the scene states map.  <br /></td></tr>
<tr class="separator:aed58f4389647aadc67b76a5db4e20bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0587e564fe1a32917b6cf4d5860be9ba" id="r_a0587e564fe1a32917b6cf4d5860be9ba"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#a0587e564fe1a32917b6cf4d5860be9ba">get_active_scenes</a> () const</td></tr>
<tr class="memdesc:a0587e564fe1a32917b6cf4d5860be9ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get list of currently active scene names (ordered).  <br /></td></tr>
<tr class="separator:a0587e564fe1a32917b6cf4d5860be9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53c13e55864ae8333a766563d8167cc" id="r_ad53c13e55864ae8333a766563d8167cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#ad53c13e55864ae8333a766563d8167cc">is_in_main_scene</a> (Entity)</td></tr>
<tr class="separator:ad53c13e55864ae8333a766563d8167cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350fe0f552eb16cde1a56d3a871983f4" id="r_a350fe0f552eb16cde1a56d3a871983f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classClock.html">Clock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#a350fe0f552eb16cde1a56d3a871983f4">clock</a> ()</td></tr>
<tr class="separator:a350fe0f552eb16cde1a56d3a871983f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05890b45956ce181802c46b7f4c130eb" id="r_a05890b45956ce181802c46b7f4c130eb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classClock.html">Clock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#a05890b45956ce181802c46b7f4c130eb">clock</a> () const</td></tr>
<tr class="separator:a05890b45956ce181802c46b7f4c130eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988dbbf41e2d34202090c4b47a17d4f7" id="r_a988dbbf41e2d34202090c4b47a17d4f7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="concepthookable.html">hookable</a> T&gt; </td></tr>
<tr class="memitem:a988dbbf41e2d34202090c4b47a17d4f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRegistry.html#a988dbbf41e2d34202090c4b47a17d4f7">register_hook</a> (std::string name, Entity const &amp;e)</td></tr>
<tr class="memdesc:a988dbbf41e2d34202090c4b47a17d4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structRegister.html">Register</a> component hooks for runtime field access.  <br /></td></tr>
<tr class="separator:a988dbbf41e2d34202090c4b47a17d4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af774fbeb95691f112557590f04e5f150" id="r_af774fbeb95691f112557590f04e5f150"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="concepthookable.html">hookable</a> T&gt; </td></tr>
<tr class="memitem:af774fbeb95691f112557590f04e5f150"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRegistry.html#af774fbeb95691f112557590f04e5f150">register_global_hook</a> (std::string const &amp;name, Entity const &amp;e)</td></tr>
<tr class="memdesc:af774fbeb95691f112557590f04e5f150"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structRegister.html">Register</a> a global hook for singleton components.  <br /></td></tr>
<tr class="separator:af774fbeb95691f112557590f04e5f150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5b1d39982cf8c8a5159f048478faf9" id="r_a3c5b1d39982cf8c8a5159f048478faf9"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="IoEvents_8hpp.html#a9479d299e1852e6140dcca1f405868aba21f40778b7db9343a6ca75ec2c41ccce">T</a> &gt; </td></tr>
<tr class="memitem:a3c5b1d39982cf8c8a5159f048478faf9"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; std::reference_wrapper&lt; <a class="el" href="IoEvents_8hpp.html#a9479d299e1852e6140dcca1f405868aba21f40778b7db9343a6ca75ec2c41ccce">T</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRegistry.html#a3c5b1d39982cf8c8a5159f048478faf9">get_hooked_value</a> (std::string const &amp;comp, std::string const &amp;value)</td></tr>
<tr class="memdesc:a3c5b1d39982cf8c8a5159f048478faf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to a hooked component field.  <br /></td></tr>
<tr class="separator:a3c5b1d39982cf8c8a5159f048478faf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4dd65895727f2f8c6c78b89f43d6fc3" id="r_aa4dd65895727f2f8c6c78b89f43d6fc3"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="IoEvents_8hpp.html#a9479d299e1852e6140dcca1f405868aba21f40778b7db9343a6ca75ec2c41ccce">T</a> &gt; </td></tr>
<tr class="memitem:aa4dd65895727f2f8c6c78b89f43d6fc3"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; std::reference_wrapper&lt; <a class="el" href="IoEvents_8hpp.html#a9479d299e1852e6140dcca1f405868aba21f40778b7db9343a6ca75ec2c41ccce">T</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRegistry.html#aa4dd65895727f2f8c6c78b89f43d6fc3">get_global_hooked_value</a> (std::string const &amp;name, std::string const &amp;value)</td></tr>
<tr class="memdesc:aa4dd65895727f2f8c6c78b89f43d6fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to a global hooked component field.  <br /></td></tr>
<tr class="separator:aa4dd65895727f2f8c6c78b89f43d6fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb34875d2a3ade0c6114886e1b41afb" id="r_a0eb34875d2a3ade0c6114886e1b41afb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#a0eb34875d2a3ade0c6114886e1b41afb">add_template</a> (std::string const &amp;name, JsonObject const &amp;config, JsonObject const &amp;default_parameters={})</td></tr>
<tr class="memdesc:a0eb34875d2a3ade0c6114886e1b41afb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structRegister.html">Register</a> an entity template for reuse.  <br /></td></tr>
<tr class="separator:a0eb34875d2a3ade0c6114886e1b41afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110e0dd5709b1c0d0838155dbb5ddbbb" id="r_a110e0dd5709b1c0d0838155dbb5ddbbb"><td class="memItemLeft" align="right" valign="top">JsonObject&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#a110e0dd5709b1c0d0838155dbb5ddbbb">get_template</a> (std::string const &amp;name, JsonObject const &amp;params={})</td></tr>
<tr class="memdesc:a110e0dd5709b1c0d0838155dbb5ddbbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a registered entity template.  <br /></td></tr>
<tr class="separator:a110e0dd5709b1c0d0838155dbb5ddbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa173e9399b055aa64d39a86ebd0d90b9" id="r_aa173e9399b055aa64d39a86ebd0d90b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#aa173e9399b055aa64d39a86ebd0d90b9">is_in_current_cene</a> (Entity e)</td></tr>
<tr class="separator:aa173e9399b055aa64d39a86ebd0d90b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649dbdf578a8498e6282d88a0d81d8d5" id="r_a649dbdf578a8498e6282d88a0d81d8d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Byte_8hpp.html#ae5dac5ad63f62fe37b5a8cfd8f269493">ByteArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#a649dbdf578a8498e6282d88a0d81d8d5">convert_comp_entity</a> (std::string const &amp;id, <a class="el" href="Byte_8hpp.html#ae5dac5ad63f62fe37b5a8cfd8f269493">ByteArray</a> const &amp;comp, std::unordered_map&lt; Entity, Entity &gt; const &amp;map)</td></tr>
<tr class="memdesc:a649dbdf578a8498e6282d88a0d81d8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert entity IDs in a serialized event using provided mapping.  <br /></td></tr>
<tr class="separator:a649dbdf578a8498e6282d88a0d81d8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c1066928e59a7aeb60ae79c08f1690" id="r_a64c1066928e59a7aeb60ae79c08f1690"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptcomponent.html">component</a> Component&gt; </td></tr>
<tr class="memitem:a64c1066928e59a7aeb60ae79c08f1690"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRegistry.html#a64c1066928e59a7aeb60ae79c08f1690">get_component_key</a> ()</td></tr>
<tr class="separator:a64c1066928e59a7aeb60ae79c08f1690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5be2ddeaa3b9cbc659a24c7f290d4e" id="r_a8c5be2ddeaa3b9cbc659a24c7f290d4e"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="Byte_8hpp.html#ae5dac5ad63f62fe37b5a8cfd8f269493">ByteArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#a8c5be2ddeaa3b9cbc659a24c7f290d4e">get_component_bytes</a> (Entity entity, std::string const &amp;component_key)</td></tr>
<tr class="separator:a8c5be2ddeaa3b9cbc659a24c7f290d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f44e83eaea9570fb48f4f20eeeb103" id="r_aa1f44e83eaea9570fb48f4f20eeeb103"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structComponentState.html">ComponentState</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#aa1f44e83eaea9570fb48f4f20eeeb103">get_state</a> ()</td></tr>
<tr class="memdesc:aa1f44e83eaea9570fb48f4f20eeeb103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the complete ECS state as serialized components.  <br /></td></tr>
<tr class="separator:aa1f44e83eaea9570fb48f4f20eeeb103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc30fce2d18248ba7e54d051fa4288d9" id="r_acc30fce2d18248ba7e54d051fa4288d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Byte_8hpp.html#ae5dac5ad63f62fe37b5a8cfd8f269493">ByteArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRegistry.html#acc30fce2d18248ba7e54d051fa4288d9">get_byte_entity</a> (Entity entity)</td></tr>
<tr class="separator:acc30fce2d18248ba7e54d051fa4288d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classRegistry.html" title="The Registry class is the core of the ECS (Entity-Component-System) architecture.">Registry</a> class is the core of the ECS (Entity-Component-System) architecture. </p>
<p>It manages entities, their associated components, and the systems that operate on them.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classRegistry.html">Registry</a> registry;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Register components</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="APlugin_8hpp.html#a84485819a678fe68f3deddaf7cb19bb4">REGISTER_COMPONENT</a>(<a class="code hl_struct" href="structPosition.html">Position</a>)</div>
<div class="line"><a class="code hl_define" href="APlugin_8hpp.html#a84485819a678fe68f3deddaf7cb19bb4">REGISTER_COMPONENT</a>(Velocity)</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Spawn entity</span></div>
<div class="line"><span class="keyword">auto</span> player = registry.<a class="code hl_function" href="classRegistry.html#a2e982e5c9b7207dce933e2210b4cce4b">spawn_entity</a>();</div>
<div class="line">registry.<a class="code hl_function" href="classRegistry.html#a9990d86dfe7f90e314f8e93773b307d4">add_component</a>(player, <a class="code hl_struct" href="structPosition.html">Position</a>{100, 200});</div>
<div class="line">registry.<a class="code hl_function" href="classRegistry.html#a9990d86dfe7f90e314f8e93773b307d4">add_component</a>(player, Velocity{5, 0});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add system</span></div>
<div class="line">registry.<a class="code hl_function" href="classRegistry.html#aee1a7222875fdfa2859b6470a741b66e">add_system</a>&lt;<a class="code hl_struct" href="structPosition.html">Position</a>, Velocity&gt;(</div>
<div class="line">  [](<a class="code hl_class" href="classRegistry.html">Registry</a>&amp; r, <span class="keyword">auto</span>&amp; pos, <span class="keyword">auto</span>&amp; vel) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; [p, v] : <a class="code hl_class" href="classZipper.html">Zipper</a>(pos, vel)) {</div>
<div class="line">      p.x += v.speed.x;</div>
<div class="line">      p.y += v.speed.y;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Game loop</span></div>
<div class="line"><span class="keywordflow">while</span> (running) {</div>
<div class="line">  registry.<a class="code hl_function" href="classRegistry.html#ae484ce9b1fdb58e76997409a74227701">run_systems</a>();  <span class="comment">// Update, process deletions, tick clock</span></div>
<div class="line">}</div>
<div class="ttc" id="aAPlugin_8hpp_html_a84485819a678fe68f3deddaf7cb19bb4"><div class="ttname"><a href="APlugin_8hpp.html#a84485819a678fe68f3deddaf7cb19bb4">REGISTER_COMPONENT</a></div><div class="ttdeci">#define REGISTER_COMPONENT(comp)</div><div class="ttdef"><b>Definition</b> APlugin.hpp:54</div></div>
<div class="ttc" id="aclassRegistry_html"><div class="ttname"><a href="classRegistry.html">Registry</a></div><div class="ttdoc">The Registry class is the core of the ECS (Entity-Component-System) architecture.</div><div class="ttdef"><b>Definition</b> Registry.hpp:308</div></div>
<div class="ttc" id="aclassRegistry_html_a2e982e5c9b7207dce933e2210b4cce4b"><div class="ttname"><a href="classRegistry.html#a2e982e5c9b7207dce933e2210b4cce4b">Registry::spawn_entity</a></div><div class="ttdeci">Entity spawn_entity()</div><div class="ttdoc">Spawns a new entity.</div><div class="ttdef"><b>Definition</b> Registry.cpp:18</div></div>
<div class="ttc" id="aclassRegistry_html_a9990d86dfe7f90e314f8e93773b307d4"><div class="ttname"><a href="classRegistry.html#a9990d86dfe7f90e314f8e93773b307d4">Registry::add_component</a></div><div class="ttdeci">SparseArray&lt; Component &gt;::Ref add_component(Entity const &amp;to, Component &amp;&amp;c)</div><div class="ttdoc">Adds a component to an entity by moving.</div><div class="ttdef"><b>Definition</b> Registry.hpp:673</div></div>
<div class="ttc" id="aclassRegistry_html_ae484ce9b1fdb58e76997409a74227701"><div class="ttname"><a href="classRegistry.html#ae484ce9b1fdb58e76997409a74227701">Registry::run_systems</a></div><div class="ttdeci">void run_systems(EventManager &amp;)</div><div class="ttdoc">Registers a system function to run every frame.</div><div class="ttdef"><b>Definition</b> Registry.cpp:73</div></div>
<div class="ttc" id="aclassRegistry_html_aee1a7222875fdfa2859b6470a741b66e"><div class="ttname"><a href="classRegistry.html#aee1a7222875fdfa2859b6470a741b66e">Registry::add_system</a></div><div class="ttdeci">void add_system(Function &amp;&amp;f, std::size_t priority=0)</div><div class="ttdoc">Adds a system that operates on specified components.</div><div class="ttdef"><b>Definition</b> Registry.hpp:834</div></div>
<div class="ttc" id="aclassZipper_html"><div class="ttname"><a href="classZipper.html">Zipper</a></div><div class="ttdoc">Range adapter that simultaneously iterates over multiple Comps.</div><div class="ttdef"><b>Definition</b> Zipper.hpp:327</div></div>
<div class="ttc" id="astructPosition_html"><div class="ttname"><a href="structPosition.html">Position</a></div><div class="ttdef"><b>Definition</b> Position.hpp:9</div></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd><a class="el" href="classRegistry.html" title="The Registry class is the core of the ECS (Entity-Component-System) architecture.">Registry</a> is non-copyable due to internal state complexity </dd>
<dd>
Thread-safety is not guaranteed - single-threaded use recommended </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="af5df0cfd429a13867b1b490b996c3e8a" name="af5df0cfd429a13867b1b490b996c3e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5df0cfd429a13867b1b490b996c3e8a">&#9670;&#160;</a></span>activate_scene()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Registry::activate_scene </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>scene_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activate a scene. </p>
<p>Sets the scene to ACTIVE state. Entities with this scene's <a class="el" href="structScene.html" title="Component that associates an entity with a specific scene.">Scene</a> component will be processed by systems.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scene_name</td><td>Name of the scene to activate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If scene doesn't exist, it will be auto-created as DISABLED then activated </dd>
<dd>
This supports dynamic scene creation from server/network </dd>
<dd>
If scene is already active, this is a no-op </dd>
<dd>
Multiple scenes can be active simultaneously</dd></dl>
<div class="fragment"><div class="line">registry.activate_scene(<span class="stringliteral">&quot;gameplay&quot;</span>);</div>
<div class="line">registry.activate_scene(<span class="stringliteral">&quot;hud&quot;</span>);  <span class="comment">// Both active now</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Auto-creates &quot;lobby&quot; scene if it doesn&#39;t exist</span></div>
<div class="line">registry.activate_scene(<span class="stringliteral">&quot;lobby&quot;</span>);  <span class="comment">// Server-sent scene</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9990d86dfe7f90e314f8e93773b307d4" name="a9990d86dfe7f90e314f8e93773b307d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9990d86dfe7f90e314f8e93773b307d4">&#9670;&#160;</a></span>add_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptcomponent.html">component</a> Component&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseArray.html">SparseArray</a>&lt; Component &gt;::Ref Registry::add_component </td>
          <td>(</td>
          <td class="paramtype">Entity const &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Component &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a component to an entity by moving. </p>
<p>Transfers ownership of a component to an entity's component storage. The component is moved into the <a class="el" href="classSparseArray.html" title="A sparse array implementation that stores components in an optional vector.">SparseArray</a> at the entity's index.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Component</td><td>The component type to add (must satisfy component concept) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>The entity to receive the component </td></tr>
    <tr><td class="paramname">c</td><td>The component to add (will be moved) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the inserted component</dd></dl>
<p>Uses perfect forwarding to efficiently move the component into storage. If entity already has this component type, it is replaced.</p>
<dl class="section note"><dt>Note</dt><dd>Entity must be valid (spawned and not killed) </dd>
<dd>
Component type must be registered first </dd>
<dd>
Prefer <a class="el" href="classRegistry.html#aedaff3e905a52a1945250cd16ffbb5fb" title="Constructs a component in-place on an entity.">emplace_component()</a> for in-place construction</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structPosition.html">Position</a> pos{100, 200, 1};</div>
<div class="line"><span class="keyword">auto</span>&amp; inserted = registry.add_component(entity, std::move(pos));</div>
<div class="line"><span class="comment">// pos is now moved-from</span></div>
<div class="line"><span class="comment">// inserted is the component in storage</span></div>
</div><!-- fragment --><div class="fragment"><div class="line">registry.add_component(player, <a class="code hl_struct" href="structPosition.html">Position</a>{0, 0});</div>
<div class="line">registry.add_component(player, Velocity{5, 5});</div>
<div class="line">registry.add_component(player, <a class="code hl_struct" href="structHealth.html">Health</a>{100, 100});</div>
<div class="ttc" id="astructHealth_html"><div class="ttname"><a href="structHealth.html">Health</a></div><div class="ttdef"><b>Definition</b> Health.hpp:9</div></div>
</div><!-- fragment --><div class="fragment"><div class="line">registry.add_component(entity, <a class="code hl_struct" href="structPosition.html">Position</a>{0, 0});</div>
<div class="line"><span class="comment">// Later...</span></div>
<div class="line">registry.add_component(entity, <a class="code hl_struct" href="structPosition.html">Position</a>{100, 50}); <span class="comment">// Replaces old position</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRegistry.html#aedaff3e905a52a1945250cd16ffbb5fb" title="Constructs a component in-place on an entity.">emplace_component()</a> for in-place construction </dd>
<dd>
<a class="el" href="classRegistry.html#ae83c694e0e30125b850edcc343406b76" title="Removes a component from an entity.">remove_component()</a> to remove components </dd></dl>

</div>
</div>
<a id="adfbcd0eed55c7f0d795443ef0f34c855" name="adfbcd0eed55c7f0d795443ef0f34c855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfbcd0eed55c7f0d795443ef0f34c855">&#9670;&#160;</a></span>add_scene()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Registry::add_scene </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>scene_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Scenes_8hpp.html#ab0d98f61608665befb0dc9afa0419e19">SceneState</a>&#160;</td>
          <td class="paramname"><em>state</em> = <code><a class="el" href="Scenes_8hpp.html#ab0d98f61608665befb0dc9afa0419e19a055c1a591abb0e8cd86dc969727bcc0b">SceneState::DISABLED</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structRegister.html">Register</a> a scene with the given name and initial state. </p>
<p>Creates a scene entry in the <a class="el" href="classRegistry.html" title="The Registry class is the core of the ECS (Entity-Component-System) architecture.">Registry</a>'s scene management system. The scene can later be activated/deactivated with <a class="el" href="classRegistry.html#af5df0cfd429a13867b1b490b996c3e8a" title="Activate a scene.">activate_scene()</a> and <a class="el" href="classRegistry.html#a754e4ccdcfee754754956ba903a86fd2" title="Deactivate a scene.">deactivate_scene()</a>.</p>
<p>This does NOT create entities - it only registers the scene metadata. Entities are associated with scenes via the <a class="el" href="structScene.html" title="Component that associates an entity with a specific scene.">Scene</a> component, typically added during <a class="el" href="classEntityLoader.html#a617fd034c346cc4ce7156b4c75b31876">EntityLoader::load_entity()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scene_name</td><td>Unique identifier for the scene </td></tr>
    <tr><td class="paramname">state</td><td>Initial activation state (default: DISABLED)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If scene already exists, this updates its state </dd>
<dd>
<a class="el" href="structScene.html" title="Component that associates an entity with a specific scene.">Scene</a> names must be unique </dd>
<dd>
Call <a class="el" href="classRegistry.html#a676be837cc2defb394f38b32d664fd30" title="Initialize the scene management system.">init_scene_management()</a> before using scenes</dd></dl>
<div class="fragment"><div class="line">registry.init_scene_management();</div>
<div class="line">registry.add_scene(<span class="stringliteral">&quot;menu&quot;</span>, <a class="code hl_enumvalue" href="Scenes_8hpp.html#ab0d98f61608665befb0dc9afa0419e19a18ff74f43da410c5529f7d6fca84f115">SceneState::ACTIVE</a>);</div>
<div class="line">registry.add_scene(<span class="stringliteral">&quot;hud&quot;</span>, <a class="code hl_enumvalue" href="Scenes_8hpp.html#ab0d98f61608665befb0dc9afa0419e19a18ff74f43da410c5529f7d6fca84f115">SceneState::ACTIVE</a>);</div>
<div class="line">registry.add_scene(<span class="stringliteral">&quot;gameplay&quot;</span>);  <span class="comment">// Defaults to DISABLED</span></div>
<div class="ttc" id="aScenes_8hpp_html_ab0d98f61608665befb0dc9afa0419e19a18ff74f43da410c5529f7d6fca84f115"><div class="ttname"><a href="Scenes_8hpp.html#ab0d98f61608665befb0dc9afa0419e19a18ff74f43da410c5529f7d6fca84f115">SceneState::ACTIVE</a></div><div class="ttdeci">@ ACTIVE</div><div class="ttdoc">Scene is active, entities are processed.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRegistry.html#a676be837cc2defb394f38b32d664fd30" title="Initialize the scene management system.">init_scene_management()</a> must be called first </dd>
<dd>
<a class="el" href="classRegistry.html#af5df0cfd429a13867b1b490b996c3e8a" title="Activate a scene.">activate_scene()</a> to activate the scene </dd>
<dd>
<a class="el" href="Scenes_8hpp.html#ab0d98f61608665befb0dc9afa0419e19" title="Defines the activation state of a scene.">SceneState</a> enum for state meanings </dd></dl>

</div>
</div>
<a id="aee1a7222875fdfa2859b6470a741b66e" name="aee1a7222875fdfa2859b6470a741b66e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee1a7222875fdfa2859b6470a741b66e">&#9670;&#160;</a></span>add_system()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Components, typename Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Registry::add_system </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>priority</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a system that operates on specified components. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Components</td><td>The types of the components the system will operate on. </td></tr>
    <tr><td class="paramname">Function</td><td>The type of the function representing the system. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function representing the system. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0eb34875d2a3ade0c6114886e1b41afb" name="a0eb34875d2a3ade0c6114886e1b41afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb34875d2a3ade0c6114886e1b41afb">&#9670;&#160;</a></span>add_template()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Registry::add_template </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JsonObject const &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JsonObject const &amp;&#160;</td>
          <td class="paramname"><em>default_parameters</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structRegister.html">Register</a> an entity template for reuse. </p>
<p>Stores a JSON configuration as a named template. Templates are entity prefabs - reusable entity definitions that can be instantiated multiple times with <a class="el" href="classEntityLoader.html#a617fd034c346cc4ce7156b4c75b31876">EntityLoader::load_entity()</a>.</p>
<p>Common use cases:</p><ul>
<li>Enemy types (basic_enemy, tank_enemy, fast_enemy)</li>
<li>Powerups (health_pack, speed_boost, shield)</li>
<li><a class="el" href="classUI.html">UI</a> elements (button, text_field, health_bar)</li>
<li>Projectiles (bullet, missile, laser)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Unique template identifier </td></tr>
    <tr><td class="paramname">config</td><td>JSON object defining the entity structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If template exists, it is overwritten </dd>
<dd>
Template names should be unique </dd>
<dd>
Templates are not validated until instantiated</dd></dl>
<div class="fragment"><div class="line">JsonObject enemy_template = {</div>
<div class="line">  {<span class="stringliteral">&quot;components&quot;</span>, {</div>
<div class="line">    {<span class="stringliteral">&quot;Position&quot;</span>, {{<span class="stringliteral">&quot;x&quot;</span>, 0}, {<span class="stringliteral">&quot;y&quot;</span>, 0}}},</div>
<div class="line">    {<span class="stringliteral">&quot;Velocity&quot;</span>, {{<span class="stringliteral">&quot;speed&quot;</span>, 50.0}}},</div>
<div class="line">    {<span class="stringliteral">&quot;Health&quot;</span>, {{<span class="stringliteral">&quot;max&quot;</span>, 100}, {<span class="stringliteral">&quot;current&quot;</span>, 100}}},</div>
<div class="line">    {<span class="stringliteral">&quot;Sprite&quot;</span>, {{<span class="stringliteral">&quot;texture&quot;</span>, <span class="stringliteral">&quot;enemy.png&quot;</span>}}}</div>
<div class="line">  }}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">registry.add_template(<span class="stringliteral">&quot;basic_enemy&quot;</span>, enemy_template);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Later, instantiate multiple enemies</span></div>
<div class="line"><span class="keyword">auto</span> config1 = registry.get_template(<span class="stringliteral">&quot;basic_enemy&quot;</span>);</div>
<div class="line">config1[<span class="stringliteral">&quot;components&quot;</span>][<span class="stringliteral">&quot;Position&quot;</span>][<span class="stringliteral">&quot;x&quot;</span>] = 100;</div>
<div class="line"><a class="code hl_class" href="classEntityLoader.html">EntityLoader</a>(registry).<a class="code hl_function" href="classEntityLoader.html#a617fd034c346cc4ce7156b4c75b31876">load_entity</a>(config1);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> config2 = registry.get_template(<span class="stringliteral">&quot;basic_enemy&quot;</span>);</div>
<div class="line">config2[<span class="stringliteral">&quot;components&quot;</span>][<span class="stringliteral">&quot;Position&quot;</span>][<span class="stringliteral">&quot;x&quot;</span>] = 200;</div>
<div class="line"><a class="code hl_class" href="classEntityLoader.html">EntityLoader</a>(registry).<a class="code hl_function" href="classEntityLoader.html#a617fd034c346cc4ce7156b4c75b31876">load_entity</a>(config2);</div>
<div class="ttc" id="aclassEntityLoader_html"><div class="ttname"><a href="classEntityLoader.html">EntityLoader</a></div><div class="ttdef"><b>Definition</b> EntityLoader.hpp:20</div></div>
<div class="ttc" id="aclassEntityLoader_html_a617fd034c346cc4ce7156b4c75b31876"><div class="ttname"><a href="classEntityLoader.html#a617fd034c346cc4ce7156b4c75b31876">EntityLoader::load_entity</a></div><div class="ttdeci">std::optional&lt; Ecs::Entity &gt; load_entity(JsonObject const &amp;config)</div><div class="ttdef"><b>Definition</b> EntityLoader.cpp:277</div></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">void</span> load_templates(<a class="code hl_class" href="classRegistry.html">Registry</a>&amp; r, <span class="keyword">const</span> std::string&amp; file_path) {</div>
<div class="line">  <span class="keyword">auto</span> json = nlohmann::json::parse(std::ifstream(file_path));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [name, config] : json[<span class="stringliteral">&quot;templates&quot;</span>].items()) {</div>
<div class="line">    r.<a class="code hl_function" href="classRegistry.html#a0eb34875d2a3ade0c6114886e1b41afb">add_template</a>(name, config);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// templates.json:</span></div>
<div class="line"><span class="comment">// {</span></div>
<div class="line"><span class="comment">//   &quot;templates&quot;: {</span></div>
<div class="line"><span class="comment">//     &quot;player&quot;: { ... },</span></div>
<div class="line"><span class="comment">//     &quot;enemy_basic&quot;: { ... },</span></div>
<div class="line"><span class="comment">//     &quot;enemy_tank&quot;: { ... }</span></div>
<div class="line"><span class="comment">//   }</span></div>
<div class="line"><span class="comment">// }</span></div>
<div class="ttc" id="aclassRegistry_html_a0eb34875d2a3ade0c6114886e1b41afb"><div class="ttname"><a href="classRegistry.html#a0eb34875d2a3ade0c6114886e1b41afb">Registry::add_template</a></div><div class="ttdeci">void add_template(std::string const &amp;name, JsonObject const &amp;config, JsonObject const &amp;default_parameters={})</div><div class="ttdoc">Register an entity template for reuse.</div><div class="ttdef"><b>Definition</b> Registry.cpp:259</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRegistry.html#a110e0dd5709b1c0d0838155dbb5ddbbb" title="Retrieve a registered entity template.">get_template()</a> to retrieve template </dd>
<dd>
<a class="el" href="classEntityLoader.html#a617fd034c346cc4ce7156b4c75b31876">EntityLoader::load_entity()</a> to instantiate template </dd></dl>

</div>
</div>
<a id="ab44989c0361996ad2c4aefbf4636b664" name="ab44989c0361996ad2c4aefbf4636b664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab44989c0361996ad2c4aefbf4636b664">&#9670;&#160;</a></span>clear_bindings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Registry::clear_bindings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all registered bindings. </p>
<p>Clears the _bindings vector, stopping all automatic field synchronization. Typically used when transitioning between game states or loading new scenes.</p>
<p>After clearing:</p><ul>
<li>Bound fields stop updating automatically</li>
<li>Field values remain at last synchronized value</li>
<li>New bindings can be registered normally</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Does not affect component data - only removes update connections </dd>
<dd>
Bindings are not automatically re-created on next frame</dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> load_new_scene(<a class="code hl_class" href="classRegistry.html">Registry</a>&amp; r) {</div>
<div class="line">  <span class="comment">// Clear old scene</span></div>
<div class="line">  r.<a class="code hl_function" href="classRegistry.html#ab44989c0361996ad2c4aefbf4636b664">clear_bindings</a>();  <span class="comment">// Remove follower AI, turret tracking, etc.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Kill old entities</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : old_scene_entities) {</div>
<div class="line">    r.<a class="code hl_function" href="classRegistry.html#a9f8e76e4f67a4e33dd7273d065d6be7a">kill_entity</a>(e);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Load new scene</span></div>
<div class="line">  load_entities_from_json(r, <span class="stringliteral">&quot;new_scene.json&quot;</span>);</div>
<div class="line">  <span class="comment">// New bindings registered during entity loading</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassRegistry_html_a9f8e76e4f67a4e33dd7273d065d6be7a"><div class="ttname"><a href="classRegistry.html#a9f8e76e4f67a4e33dd7273d065d6be7a">Registry::kill_entity</a></div><div class="ttdeci">void kill_entity(Entity const &amp;e)</div><div class="ttdoc">Marks an entity for deletion.</div><div class="ttdef"><b>Definition</b> Registry.cpp:31</div></div>
<div class="ttc" id="aclassRegistry_html_ab44989c0361996ad2c4aefbf4636b664"><div class="ttname"><a href="classRegistry.html#ab44989c0361996ad2c4aefbf4636b664">Registry::clear_bindings</a></div><div class="ttdeci">void clear_bindings()</div><div class="ttdoc">Removes all registered bindings.</div><div class="ttdef"><b>Definition</b> Registry.cpp:100</div></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">void</span> enter_pause_menu(<a class="code hl_class" href="classRegistry.html">Registry</a>&amp; r) {</div>
<div class="line">  r.<a class="code hl_function" href="classRegistry.html#ab44989c0361996ad2c4aefbf4636b664">clear_bindings</a>();  <span class="comment">// Stop all dynamic behaviors</span></div>
<div class="line">  <span class="comment">// Game entities frozen</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> resume_game(<a class="code hl_class" href="classRegistry.html">Registry</a>&amp; r) {</div>
<div class="line">  <span class="comment">// Bindings must be re-registered if needed</span></div>
<div class="line">  setup_gameplay_bindings(r);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRegistry.html#a529bdf9002188825f7b03f33b2991624" title="Registers a dynamic binding between component fields.">register_binding()</a> to create new bindings </dd>
<dd>
<a class="el" href="classRegistry.html#ae99ff1a3c4f750cba3bb80534f4295c4" title="Updates all registered dynamic bindings.">update_bindings()</a> which processes bindings </dd></dl>

</div>
</div>
<a id="a350fe0f552eb16cde1a56d3a871983f4" name="a350fe0f552eb16cde1a56d3a871983f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a350fe0f552eb16cde1a56d3a871983f4">&#9670;&#160;</a></span>clock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classClock.html">Clock</a> &amp; Registry::clock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a05890b45956ce181802c46b7f4c130eb" name="a05890b45956ce181802c46b7f4c130eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05890b45956ce181802c46b7f4c130eb">&#9670;&#160;</a></span>clock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classClock.html">Clock</a> &amp; Registry::clock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a649dbdf578a8498e6282d88a0d81d8d5" name="a649dbdf578a8498e6282d88a0d81d8d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649dbdf578a8498e6282d88a0d81d8d5">&#9670;&#160;</a></span>convert_comp_entity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Byte_8hpp.html#ae5dac5ad63f62fe37b5a8cfd8f269493">ByteArray</a> Registry::convert_comp_entity </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Byte_8hpp.html#ae5dac5ad63f62fe37b5a8cfd8f269493">ByteArray</a> const &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; Entity, Entity &gt; const &amp;&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert entity IDs in a serialized event using provided mapping. </p>
<p>Remaps entity references in component data from one ID space to another. Similar to convert_component_entity() but for events. Used when synchronizing event state over network.</p>
<p>The component type must implement change_entity(map) method that returns a new event with remapped IDs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>event type string identifier </td></tr>
    <tr><td class="paramname">event</td><td>Serialized event data (binary format) </td></tr>
    <tr><td class="paramname">map</td><td>Entity ID mapping (old ID -&gt; new ID) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Serialized event with remapped entity IDs</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If event type not registered</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>event type must have change_entity() method</dd></dl>
<p>Convert entity IDs in a serialized component using provided mapping.</p>
<p>Remaps entity references in component data from one ID space to another. Similar to convert_event_entity() but for components. Used when synchronizing component state over network.</p>
<p>The component type must implement change_entity(map) method that returns a new component with remapped IDs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Component type string identifier </td></tr>
    <tr><td class="paramname">comp</td><td>Serialized component data (binary format) </td></tr>
    <tr><td class="paramname">map</td><td>Entity ID mapping (old ID -&gt; new ID) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Serialized component with remapped entity IDs</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If component type not registered</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Component type must have change_entity() method </dd></dl>

</div>
</div>
<a id="a08789766bb87dcda9159cc2405249b32" name="a08789766bb87dcda9159cc2405249b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08789766bb87dcda9159cc2405249b32">&#9670;&#160;</a></span>deactivate_all_scenes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Registry::deactivate_all_scenes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deactivate all scenes. </p>
<p>Sets all scenes to DISABLED state. No entities will be processed by systems until scenes are reactivated. </p>

</div>
</div>
<a id="a754e4ccdcfee754754956ba903a86fd2" name="a754e4ccdcfee754754956ba903a86fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754e4ccdcfee754754956ba903a86fd2">&#9670;&#160;</a></span>deactivate_scene()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Registry::deactivate_scene </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>scene_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deactivate a scene. </p>
<p>Sets the scene to DISABLED state. Entities in this scene will no longer be processed by systems until the scene is reactivated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scene_name</td><td>Name of the scene to deactivate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Safe to call with non-existent scene names (no-op) </dd>
<dd>
<a class="el" href="structScene.html" title="Component that associates an entity with a specific scene.">Scene</a> can be reactivated later with <a class="el" href="classRegistry.html#af5df0cfd429a13867b1b490b996c3e8a" title="Activate a scene.">activate_scene()</a> </dd></dl>

</div>
</div>
<a id="aedaff3e905a52a1945250cd16ffbb5fb" name="aedaff3e905a52a1945250cd16ffbb5fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedaff3e905a52a1945250cd16ffbb5fb">&#9670;&#160;</a></span>emplace_component() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Component , typename... Params&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseArray.html">SparseArray</a>&lt; Component &gt;::Ref Registry::emplace_component </td>
          <td>(</td>
          <td class="paramtype">Entity const &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Params &amp;&amp;...&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a component in-place on an entity. </p>
<p>Creates a component directly in storage by forwarding constructor arguments. More efficient than <a class="el" href="classRegistry.html#a9990d86dfe7f90e314f8e93773b307d4" title="Adds a component to an entity by moving.">add_component()</a> when constructing from parameters.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Component</td><td>The component type to construct </td></tr>
    <tr><td class="paramname">Params</td><td>Constructor parameter types (deduced) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>The entity to receive the component </td></tr>
    <tr><td class="paramname">p</td><td>Constructor arguments forwarded to Component constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the constructed component</dd></dl>
<p>Constructs the component directly in the <a class="el" href="classSparseArray.html" title="A sparse array implementation that stores components in an optional vector.">SparseArray</a>, avoiding temporary objects and move operations. Equivalent to: </p><div class="fragment"><div class="line">storage[entity] = Component(args...);  <span class="comment">// But without temporary</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>More efficient than <a class="el" href="classRegistry.html#a9990d86dfe7f90e314f8e93773b307d4" title="Adds a component to an entity by moving.">add_component()</a> for complex components </dd>
<dd>
Replaces existing component if present</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Direct construction</span></div>
<div class="line">registry.emplace_component&lt;<a class="code hl_struct" href="structPosition.html">Position</a>&gt;(entity, 100.0, 200.0, 1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Equivalent to (but more efficient than):</span></div>
<div class="line">registry.add_component(entity, <a class="code hl_struct" href="structPosition.html">Position</a>(100.0, 200.0, 1));</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Sprite with multiple parameters</span></div>
<div class="line">registry.emplace_component&lt;<a class="code hl_struct" href="structSprite.html">Sprite</a>&gt;(</div>
<div class="line">  entity,</div>
<div class="line">  <span class="stringliteral">&quot;player.png&quot;</span>,           <span class="comment">// texture</span></div>
<div class="line">  <a class="code hl_struct" href="structRect.html">Rect</a>{0, 0, 32, 32},    <span class="comment">// source rect</span></div>
<div class="line">  <a class="code hl_class" href="classVector2D.html">Vector2D</a>{16, 16},      <span class="comment">// origin</span></div>
<div class="line">  Color::WHITE           <span class="comment">// tint</span></div>
<div class="line">);</div>
<div class="ttc" id="aclassVector2D_html"><div class="ttname"><a href="classVector2D.html">Vector2D</a></div><div class="ttdoc">Two-dimensional vector with mathematical operations.</div><div class="ttdef"><b>Definition</b> Vector2D.hpp:44</div></div>
<div class="ttc" id="astructRect_html"><div class="ttname"><a href="structRect.html">Rect</a></div><div class="ttdoc">Center-based rectangle with collision detection methods.</div><div class="ttdef"><b>Definition</b> Rect.hpp:22</div></div>
<div class="ttc" id="astructSprite_html"><div class="ttname"><a href="structSprite.html">Sprite</a></div><div class="ttdef"><b>Definition</b> Sprite.hpp:12</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRegistry.html#a9990d86dfe7f90e314f8e93773b307d4" title="Adds a component to an entity by moving.">add_component()</a> to move existing components </dd></dl>

</div>
</div>
<a id="a02e78bd26f93b8cf996f457389c422f3" name="a02e78bd26f93b8cf996f457389c422f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e78bd26f93b8cf996f457389c422f3">&#9670;&#160;</a></span>emplace_component() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Registry::emplace_component </td>
          <td>(</td>
          <td class="paramtype">Entity const &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>string_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Byte_8hpp.html#ae5dac5ad63f62fe37b5a8cfd8f269493">ByteArray</a> const &amp;&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a component from binary data by string ID. </p>
<p>Deserializes a component from a byte array and attaches it to an entity. Used for network synchronization and state loading.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>The entity to receive the component </td></tr>
    <tr><td class="paramname">string_id</td><td>The component type identifier (from registration) </td></tr>
    <tr><td class="paramname">bytes</td><td>Binary representation of the component</td></tr>
  </table>
  </dd>
</dl>
<p>Lookup process:</p><ol type="1">
<li>Find type_index via string_id in _index_getter</li>
<li>Find emplace function in _emplace_functions</li>
<li>Call function to deserialize and insert component</li>
</ol>
<p>If string_id is unknown, prints error to stderr and does nothing.</p>
<dl class="section note"><dt>Note</dt><dd>Component type must be registered with this string_id </dd>
<dd>
Byte array must be valid serialized component data </dd>
<dd>
Used internally by network systems</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Server sends component update</span></div>
<div class="line"><a class="code hl_typedef" href="Byte_8hpp.html#ae5dac5ad63f62fe37b5a8cfd8f269493">ByteArray</a> bytes = position_component.to_bytes();</div>
<div class="line">network.send(client, <span class="stringliteral">&quot;Position&quot;</span>, bytes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Client receives and applies</span></div>
<div class="line">std::string comp_id;</div>
<div class="line"><a class="code hl_typedef" href="Byte_8hpp.html#ae5dac5ad63f62fe37b5a8cfd8f269493">ByteArray</a> data;</div>
<div class="line">network.receive(comp_id, data);</div>
<div class="line">registry.emplace_component(entity, comp_id, data);</div>
<div class="ttc" id="aByte_8hpp_html_ae5dac5ad63f62fe37b5a8cfd8f269493"><div class="ttname"><a href="Byte_8hpp.html#ae5dac5ad63f62fe37b5a8cfd8f269493">ByteArray</a></div><div class="ttdeci">std::vector&lt; Byte &gt; ByteArray</div><div class="ttdef"><b>Definition</b> Byte.hpp:27</div></div>
</div><!-- fragment --><div class="fragment"><div class="line"><a class="code hl_struct" href="structComponentState.html">ComponentState</a> state = load_from_file(<span class="stringliteral">&quot;save.dat&quot;</span>);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; [entity_id, comp_data] : state.comps) {</div>
<div class="line">  registry.emplace_component(entity_id, state.<a class="code hl_variable" href="structComponentState.html#a994fa4db9043fd49c780e12f098af193">id</a>, comp_data);</div>
<div class="line">}</div>
<div class="ttc" id="astructComponentState_html"><div class="ttname"><a href="structComponentState.html">ComponentState</a></div><div class="ttdoc">Captures the state of a component type across all entities.</div><div class="ttdef"><b>Definition</b> ComponentState.hpp:24</div></div>
<div class="ttc" id="astructComponentState_html_a994fa4db9043fd49c780e12f098af193"><div class="ttname"><a href="structComponentState.html#a994fa4db9043fd49c780e12f098af193">ComponentState::id</a></div><div class="ttdeci">std::string id</div><div class="ttdoc">Component type identifier (format: &quot;plugin:component&quot;)</div><div class="ttdef"><b>Definition</b> ComponentState.hpp:25</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRegistry.html#aa3c7728231c60cf0e6742d693aa50bbf" title="Registers a bytable component type with a string identifier.">register_component()</a> which sets up the emplace function </dd>
<dd>
<a class="el" href="structComponentState.html" title="Captures the state of a component type across all entities.">ComponentState</a> for serialization format </dd></dl>

</div>
</div>
<a id="a0587e564fe1a32917b6cf4d5860be9ba" name="a0587e564fe1a32917b6cf4d5860be9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0587e564fe1a32917b6cf4d5860be9ba">&#9670;&#160;</a></span>get_active_scenes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; const  &amp; Registry::get_active_scenes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get list of currently active scene names (ordered). </p>
<dl class="section return"><dt>Returns</dt><dd>Vector of active scene names in stack order </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd><a class="el" href="structUse.html">Use</a> <a class="el" href="classRegistry.html#a4ea8e3e48003a382c1391520a5e2dfba" title="Get the set of active scene names for O(1) lookups.">get_active_scenes_set()</a> for most use cases </dd></dl>

</div>
</div>
<a id="a4ea8e3e48003a382c1391520a5e2dfba" name="a4ea8e3e48003a382c1391520a5e2dfba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea8e3e48003a382c1391520a5e2dfba">&#9670;&#160;</a></span>get_active_scenes_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; std::string &gt; const  &amp; Registry::get_active_scenes_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the set of active scene names for <a class="el" href="IoEvents_8hpp.html#a9479d299e1852e6140dcca1f405868abaf4b8b7698dfedf5562a7db2bdb07010a">O(1)</a> lookups. </p>
<dl class="section return"><dt>Returns</dt><dd>Unordered set of active scene names </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="classZipper.html" title="Range adapter that simultaneously iterates over multiple Comps.">Zipper</a> for efficient filtering </dd></dl>

</div>
</div>
<a id="acc30fce2d18248ba7e54d051fa4288d9" name="acc30fce2d18248ba7e54d051fa4288d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc30fce2d18248ba7e54d051fa4288d9">&#9670;&#160;</a></span>get_byte_entity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Byte_8hpp.html#ae5dac5ad63f62fe37b5a8cfd8f269493">ByteArray</a> Registry::get_byte_entity </td>
          <td>(</td>
          <td class="paramtype">Entity&#160;</td>
          <td class="paramname"><em>entity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c5be2ddeaa3b9cbc659a24c7f290d4e" name="a8c5be2ddeaa3b9cbc659a24c7f290d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c5be2ddeaa3b9cbc659a24c7f290d4e">&#9670;&#160;</a></span>get_component_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="Byte_8hpp.html#ae5dac5ad63f62fe37b5a8cfd8f269493">ByteArray</a> &gt; Registry::get_component_bytes </td>
          <td>(</td>
          <td class="paramtype">Entity&#160;</td>
          <td class="paramname"><em>entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>component_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a64c1066928e59a7aeb60ae79c08f1690" name="a64c1066928e59a7aeb60ae79c08f1690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c1066928e59a7aeb60ae79c08f1690">&#9670;&#160;</a></span>get_component_key()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptcomponent.html">component</a> Component&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Registry::get_component_key </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8ff3522b765d882b46262ad345db07b" name="ab8ff3522b765d882b46262ad345db07b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ff3522b765d882b46262ad345db07b">&#9670;&#160;</a></span>get_components() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Component &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseArray.html">SparseArray</a>&lt; Component &gt; &amp; Registry::get_components </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the components object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Component</td><td>The type of the component to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SparseArray&lt;Component&gt;&amp; A reference to the sparse array of the specified component type.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_any_cast</td><td>if component type not registered </td></tr>
    <tr><td class="paramname">std::out_of_range</td><td>if component type not found</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Component must be registered via <a class="el" href="classRegistry.html#aa3c7728231c60cf0e6742d693aa50bbf" title="Registers a bytable component type with a string identifier.">register_component()</a> first </dd>
<dd>
Make sure to use <a class="el" href="classZipper.html" title="Range adapter that simultaneously iterates over multiple Comps.">Zipper</a> or <a class="el" href="classZipperIndex.html" title="Range adapter that zips multiple Comps and includes indices in the iteration.">ZipperIndex</a> </dd></dl>

</div>
</div>
<a id="afdce4af207b1240a6c10b83ad66cc4b4" name="afdce4af207b1240a6c10b83ad66cc4b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdce4af207b1240a6c10b83ad66cc4b4">&#9670;&#160;</a></span>get_components() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Component &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseArray.html">SparseArray</a>&lt; Component &gt; const  &amp; Registry::get_components </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as SparseArray&lt;Component&gt;&amp; <a class="el" href="classRegistry.html#ab8ff3522b765d882b46262ad345db07b" title="Get the components object.">get_components()</a> but const <a class="el" href="classRegistry.html#ab8ff3522b765d882b46262ad345db07b" title="Get the components object.">get_components()</a></p>
<p><a class="el" href="classRegistry.html#ab8ff3522b765d882b46262ad345db07b" title="Get the components object.">get_components()</a> </p>

</div>
</div>
<a id="a0b9eb2723831a87cb5602c43e2b05b0a" name="a0b9eb2723831a87cb5602c43e2b05b0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b9eb2723831a87cb5602c43e2b05b0a">&#9670;&#160;</a></span>get_current_scene()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; const  &amp; Registry::get_current_scene </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get list of currently active scene names. </p>
<p>Returns the names of all scenes in MAIN or ACTIVE state. DISABLED scenes are not included. The order may be significant (MAIN typically first).</p>
<dl class="section return"><dt>Returns</dt><dd>Vector of active scene names (may be empty)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Returned vector is const - use set/remove to modify scenes </dd>
<dd>
Empty vector means no scenes are active</dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> show_debug_info(<a class="code hl_class" href="classRegistry.html">Registry</a>&amp; r) {</div>
<div class="line">  <span class="keyword">auto</span> scenes = r.<a class="code hl_function" href="classRegistry.html#a0b9eb2723831a87cb5602c43e2b05b0a">get_current_scene</a>();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Active scenes: &quot;</span>;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; scene : scenes) {</div>
<div class="line">    std::cout &lt;&lt; scene &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
<div class="ttc" id="aclassRegistry_html_a0b9eb2723831a87cb5602c43e2b05b0a"><div class="ttname"><a href="classRegistry.html#a0b9eb2723831a87cb5602c43e2b05b0a">Registry::get_current_scene</a></div><div class="ttdeci">std::vector&lt; std::string &gt; const &amp; get_current_scene() const</div><div class="ttdoc">Get list of currently active scene names.</div><div class="ttdef"><b>Definition</b> Registry.cpp:234</div></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">void</span> update_system(<a class="code hl_class" href="classRegistry.html">Registry</a>&amp; r) {</div>
<div class="line">  <span class="keyword">auto</span> scenes = r.<a class="code hl_function" href="classRegistry.html#a0b9eb2723831a87cb5602c43e2b05b0a">get_current_scene</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Check if gameplay is active</span></div>
<div class="line">  <span class="keywordtype">bool</span> in_game = std::find(scenes.begin(), scenes.end(), <span class="stringliteral">&quot;gameplay&quot;</span>)</div>
<div class="line">                 != scenes.end();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (in_game) {</div>
<div class="line">    <span class="comment">// Run gameplay logic</span></div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRegistry.html#ad1c9d136cf9da966ef0977d3c698a963" title="Activate a scene, making its entities visible to systems.">set_current_scene()</a> to modify active scenes </dd>
<dd>
is_in_current_scene() to check specific entity </dd></dl>

</div>
</div>
<a id="aa4dd65895727f2f8c6c78b89f43d6fc3" name="aa4dd65895727f2f8c6c78b89f43d6fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4dd65895727f2f8c6c78b89f43d6fc3">&#9670;&#160;</a></span>get_global_hooked_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="IoEvents_8hpp.html#a9479d299e1852e6140dcca1f405868aba21f40778b7db9343a6ca75ec2c41ccce">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::reference_wrapper&lt; <a class="el" href="IoEvents_8hpp.html#a9479d299e1852e6140dcca1f405868aba21f40778b7db9343a6ca75ec2c41ccce">T</a> &gt; &gt; Registry::get_global_hooked_value </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a reference to a global hooked component field. </p>
<p>Similar to <a class="el" href="classRegistry.html#a3c5b1d39982cf8c8a5159f048478faf9" title="Retrieve a reference to a hooked component field.">get_hooked_value()</a> but for global (singleton) components. Returns a reference to a field from a globally registered component.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Field type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Global hook name (from <a class="el" href="classRegistry.html#af774fbeb95691f112557590f04e5f150" title="Register a global hook for singleton components.">register_global_hook()</a>) </td></tr>
    <tr><td class="paramname">value</td><td>Field name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Optional reference to the field, or std::nullopt if not found </dd></dl>

</div>
</div>
<a id="a3c5b1d39982cf8c8a5159f048478faf9" name="a3c5b1d39982cf8c8a5159f048478faf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5b1d39982cf8c8a5159f048478faf9">&#9670;&#160;</a></span>get_hooked_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="IoEvents_8hpp.html#a9479d299e1852e6140dcca1f405868aba21f40778b7db9343a6ca75ec2c41ccce">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::reference_wrapper&lt; <a class="el" href="IoEvents_8hpp.html#a9479d299e1852e6140dcca1f405868aba21f40778b7db9343a6ca75ec2c41ccce">T</a> &gt; &gt; Registry::get_hooked_value </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a reference to a hooked component field. </p>
<p>Returns a reference to a specific field of a hooked component. The component must have been registered with <a class="el" href="classRegistry.html#a988dbbf41e2d34202090c4b47a17d4f7" title="Register component hooks for runtime field access.">register_hook()</a>. Returns std::nullopt if the hook name doesn't exist, the entity was deleted, or the field name is invalid.</p>
<p>The returned value is a reference_wrapper - changes to the original field are reflected in the reference.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Field type (must match the actual field type) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>Hook name (from <a class="el" href="classRegistry.html#a988dbbf41e2d34202090c4b47a17d4f7" title="Register component hooks for runtime field access.">register_hook()</a>) </td></tr>
    <tr><td class="paramname">value</td><td>Field name (from <a class="el" href="HookMacros_8hpp.html#a64db554aa76425e63b60d0fd6ccb1e26" title="Registers a component field using its variable name as the hook key.">HOOK()</a> declaration) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Optional reference to the field, or std::nullopt if not found</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Returns std::nullopt if hook name is invalid </dd>
<dd>
Returns std::nullopt if entity no longer has component </dd>
<dd>
Returns std::nullopt if field name is invalid </dd>
<dd>
Returned reference is valid until component is removed</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Setup</span></div>
<div class="line">registry.register_hook&lt;<a class="code hl_struct" href="structPosition.html">Position</a>&gt;(<span class="stringliteral">&quot;player&quot;</span>, player_entity);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Read field</span></div>
<div class="line"><span class="keyword">auto</span> x_ref = registry.get_hooked_value&lt;<span class="keywordtype">float</span>&gt;(<span class="stringliteral">&quot;player&quot;</span>, <span class="stringliteral">&quot;x&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (x_ref) {</div>
<div class="line">  <span class="keywordtype">float</span> x = x_ref-&gt;get();  <span class="comment">// Dereference reference_wrapper</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Player X: &quot;</span> &lt;&lt; x &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">auto</span> health_ref = registry.get_hooked_value&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;player&quot;</span>, <span class="stringliteral">&quot;health&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (health_ref) {</div>
<div class="line">  health_ref-&gt;get() -= 10;  <span class="comment">// Modify original component field</span></div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><a class="code hl_enumvalue" href="IoEvents_8hpp.html#a9479d299e1852e6140dcca1f405868aba21f40778b7db9343a6ca75ec2c41ccce">T</a> get_config_value(<a class="code hl_class" href="classRegistry.html">Registry</a>&amp; r, <span class="keyword">const</span> std::string&amp; key) {</div>
<div class="line">  <span class="comment">// Config stored in &quot;GameConfig&quot; hook</span></div>
<div class="line">  <span class="keyword">auto</span> ref = r.<a class="code hl_function" href="classRegistry.html#a3c5b1d39982cf8c8a5159f048478faf9">get_hooked_value</a>&lt;<a class="code hl_enumvalue" href="IoEvents_8hpp.html#a9479d299e1852e6140dcca1f405868aba21f40778b7db9343a6ca75ec2c41ccce">T</a>&gt;(<span class="stringliteral">&quot;GameConfig&quot;</span>, key);</div>
<div class="line">  <span class="keywordflow">if</span> (ref) {</div>
<div class="line">    <span class="keywordflow">return</span> ref-&gt;get();</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Config key not found: &quot;</span> + key);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">float</span> gravity = get_config_value&lt;float&gt;(registry, <span class="stringliteral">&quot;gravity&quot;</span>);</div>
<div class="line"><span class="keywordtype">int</span> max_enemies = get_config_value&lt;int&gt;(registry, <span class="stringliteral">&quot;max_enemies&quot;</span>);</div>
<div class="ttc" id="aIoEvents_8hpp_html_a9479d299e1852e6140dcca1f405868aba21f40778b7db9343a6ca75ec2c41ccce"><div class="ttname"><a href="IoEvents_8hpp.html#a9479d299e1852e6140dcca1f405868aba21f40778b7db9343a6ca75ec2c41ccce">T</a></div><div class="ttdeci">@ T</div><div class="ttdef"><b>Definition</b> IoEvents.hpp:54</div></div>
<div class="ttc" id="aclassRegistry_html_a3c5b1d39982cf8c8a5159f048478faf9"><div class="ttname"><a href="classRegistry.html#a3c5b1d39982cf8c8a5159f048478faf9">Registry::get_hooked_value</a></div><div class="ttdeci">std::optional&lt; std::reference_wrapper&lt; T &gt; &gt; get_hooked_value(std::string const &amp;comp, std::string const &amp;value)</div><div class="ttdoc">Retrieve a reference to a hooked component field.</div><div class="ttdef"><b>Definition</b> Registry.hpp:1893</div></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">void</span> update_enemy_ai(<a class="code hl_class" href="classRegistry.html">Registry</a>&amp; r, Entity enemy) {</div>
<div class="line">  <span class="comment">// Track player position through hook</span></div>
<div class="line">  <span class="keyword">auto</span> target_x = r.<a class="code hl_function" href="classRegistry.html#a3c5b1d39982cf8c8a5159f048478faf9">get_hooked_value</a>&lt;<span class="keywordtype">float</span>&gt;(<span class="stringliteral">&quot;player&quot;</span>, <span class="stringliteral">&quot;x&quot;</span>);</div>
<div class="line">  <span class="keyword">auto</span> target_y = r.<a class="code hl_function" href="classRegistry.html#a3c5b1d39982cf8c8a5159f048478faf9">get_hooked_value</a>&lt;<span class="keywordtype">float</span>&gt;(<span class="stringliteral">&quot;player&quot;</span>, <span class="stringliteral">&quot;y&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (target_x &amp;&amp; target_y) {</div>
<div class="line">    <span class="keyword">auto</span>&amp; enemy_pos = r.<a class="code hl_function" href="classRegistry.html#ab8ff3522b765d882b46262ad345db07b">get_components</a>&lt;<a class="code hl_struct" href="structPosition.html">Position</a>&gt;()[enemy];</div>
<div class="line">    <span class="keywordflow">if</span> (enemy_pos) {</div>
<div class="line">      <span class="comment">// Move towards player</span></div>
<div class="line">      <span class="keywordtype">float</span> dx = target_x-&gt;get() - enemy_pos-&gt;x;</div>
<div class="line">      <span class="keywordtype">float</span> dy = target_y-&gt;get() - enemy_pos-&gt;y;</div>
<div class="line">      <span class="comment">// ... movement logic</span></div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="aclassRegistry_html_ab8ff3522b765d882b46262ad345db07b"><div class="ttname"><a href="classRegistry.html#ab8ff3522b765d882b46262ad345db07b">Registry::get_components</a></div><div class="ttdeci">SparseArray&lt; Component &gt; &amp; get_components()</div><div class="ttdoc">Get the components object.</div><div class="ttdef"><b>Definition</b> Registry.hpp:396</div></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// This is how register_binding() uses get_hooked_value()</span></div>
<div class="line"><span class="keywordtype">void</span> sync_follower_position(<a class="code hl_class" href="classRegistry.html">Registry</a>&amp; r, Entity follower) {</div>
<div class="line">  <span class="keyword">auto</span> leader_x = r.<a class="code hl_function" href="classRegistry.html#a3c5b1d39982cf8c8a5159f048478faf9">get_hooked_value</a>&lt;<span class="keywordtype">float</span>&gt;(<span class="stringliteral">&quot;leader&quot;</span>, <span class="stringliteral">&quot;x&quot;</span>);</div>
<div class="line">  <span class="keyword">auto</span> leader_y = r.<a class="code hl_function" href="classRegistry.html#a3c5b1d39982cf8c8a5159f048478faf9">get_hooked_value</a>&lt;<span class="keywordtype">float</span>&gt;(<span class="stringliteral">&quot;leader&quot;</span>, <span class="stringliteral">&quot;y&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (leader_x &amp;&amp; leader_y) {</div>
<div class="line">    <span class="keyword">auto</span>&amp; follower_pos = r.<a class="code hl_function" href="classRegistry.html#ab8ff3522b765d882b46262ad345db07b">get_components</a>&lt;<a class="code hl_struct" href="structPosition.html">Position</a>&gt;()[follower];</div>
<div class="line">    <span class="keywordflow">if</span> (follower_pos) {</div>
<div class="line">      follower_pos-&gt;x = leader_x-&gt;get();</div>
<div class="line">      follower_pos-&gt;y = leader_y-&gt;get();</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">void</span> debug_print_hook(<a class="code hl_class" href="classRegistry.html">Registry</a>&amp; r, <span class="keyword">const</span> std::string&amp; hook_name) {</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Hook &#39;&quot;</span> &lt;&lt; hook_name &lt;&lt; <span class="stringliteral">&quot;&#39; fields:\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Try common field names</span></div>
<div class="line">  <span class="keyword">auto</span> x = r.<a class="code hl_function" href="classRegistry.html#a3c5b1d39982cf8c8a5159f048478faf9">get_hooked_value</a>&lt;<span class="keywordtype">float</span>&gt;(hook_name, <span class="stringliteral">&quot;x&quot;</span>);</div>
<div class="line">  <span class="keywordflow">if</span> (x) std::cout &lt;&lt; <span class="stringliteral">&quot;  x: &quot;</span> &lt;&lt; x-&gt;get() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> y = r.<a class="code hl_function" href="classRegistry.html#a3c5b1d39982cf8c8a5159f048478faf9">get_hooked_value</a>&lt;<span class="keywordtype">float</span>&gt;(hook_name, <span class="stringliteral">&quot;y&quot;</span>);</div>
<div class="line">  <span class="keywordflow">if</span> (y) std::cout &lt;&lt; <span class="stringliteral">&quot;  y: &quot;</span> &lt;&lt; y-&gt;get() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> health = r.<a class="code hl_function" href="classRegistry.html#a3c5b1d39982cf8c8a5159f048478faf9">get_hooked_value</a>&lt;<span class="keywordtype">int</span>&gt;(hook_name, <span class="stringliteral">&quot;health&quot;</span>);</div>
<div class="line">  <span class="keywordflow">if</span> (health) std::cout &lt;&lt; <span class="stringliteral">&quot;  health: &quot;</span> &lt;&lt; health-&gt;get() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRegistry.html#a988dbbf41e2d34202090c4b47a17d4f7" title="Register component hooks for runtime field access.">register_hook()</a> to register <a class="el" href="conceptcomponent.html" title="Requires a type to be serializable and entity-convertible for network sync.">component</a> hooks </dd>
<dd>
<a class="el" href="classRegistry.html#a529bdf9002188825f7b03f33b2991624" title="Registers a dynamic binding between component fields.">register_binding()</a> which uses this for dynamic data binding </dd>
<dd>
<a class="el" href="HookMacros_8hpp.html#a8f0cb5d5dff2b9cbbd63e1e50cc30e6a" title="Makes a component type hookable by generating a static hook map.">HOOKABLE()</a> macro for declaring <a class="el" href="concepthookable.html" title="Requires a type to provide a static hook_map() method.">hookable</a> fields </dd></dl>

</div>
</div>
<a id="a1218f67393c0188a60c152126a1a5e09" name="a1218f67393c0188a60c152126a1a5e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1218f67393c0188a60c152126a1a5e09">&#9670;&#160;</a></span>get_scene_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Scenes_8hpp.html#ab0d98f61608665befb0dc9afa0419e19">SceneState</a> Registry::get_scene_state </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>scene_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the state of a scene. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scene_name</td><td>Name of the scene </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scene's state, or DISABLED if scene doesn't exist </dd></dl>

</div>
</div>
<a id="aed58f4389647aadc67b76a5db4e20bb3" name="aed58f4389647aadc67b76a5db4e20bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed58f4389647aadc67b76a5db4e20bb3">&#9670;&#160;</a></span>get_scene_states()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; std::string, <a class="el" href="Scenes_8hpp.html#ab0d98f61608665befb0dc9afa0419e19">SceneState</a> &gt; const  &amp; Registry::get_scene_states </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the scene states map. </p>
<dl class="section return"><dt>Returns</dt><dd>Unordered map of scene names to their states </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="classZipper.html" title="Range adapter that simultaneously iterates over multiple Comps.">Zipper</a> for scene level filtering </dd></dl>

</div>
</div>
<a id="aa1f44e83eaea9570fb48f4f20eeeb103" name="aa1f44e83eaea9570fb48f4f20eeeb103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f44e83eaea9570fb48f4f20eeeb103">&#9670;&#160;</a></span>get_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structComponentState.html">ComponentState</a> &gt; Registry::get_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the complete ECS state as serialized components. </p>
<p>Captures a snapshot of all component data across all entities. Returns a vector where each entry contains one component type's complete state: the component type identifier and all (entity, component data) pairs.</p>
<p>This is used for:</p><ul>
<li>Full state synchronization for new players</li>
<li>Save/load game functionality</li>
<li>Replay recording</li>
<li>State diffing for delta compression</li>
</ul>
<p>The returned data is fully serialized and can be transmitted over network or written to disk.</p>
<dl class="section return"><dt>Returns</dt><dd>Vector of <a class="el" href="structComponentState.html" title="Captures the state of a component type across all entities.">ComponentState</a> (one per component type)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a complete snapshot - can be large for complex worlds </dd>
<dd>
Each <a class="el" href="structComponentState.html" title="Captures the state of a component type across all entities.">ComponentState</a> contains component ID and entity-data pairs </dd>
<dd>
Order is not guaranteed</dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> send_world_state_to_new_player(<a class="code hl_class" href="classRegistry.html">Registry</a>&amp; server_registry,</div>
<div class="line">                                    NetworkClient&amp; client,</div>
<div class="line">                                    <span class="keyword">const</span> EntityMapping&amp; id_map) {</div>
<div class="line">  <span class="comment">// Get complete server state</span></div>
<div class="line">  <span class="keyword">auto</span> state = server_registry.<a class="code hl_function" href="classRegistry.html#aa1f44e83eaea9570fb48f4f20eeeb103">get_state</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Send each component type</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; comp_state : state) {</div>
<div class="line">    <span class="comment">// comp_state.id = &quot;Position&quot;, &quot;Velocity&quot;, etc.</span></div>
<div class="line">    <span class="comment">// comp_state.comps = [(entity, bytes), (entity, bytes), ...]</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [entity, data] : comp_state.comps) {</div>
<div class="line">      <span class="comment">// Remap entity IDs to client space</span></div>
<div class="line">      <a class="code hl_typedef" href="Byte_8hpp.html#ae5dac5ad63f62fe37b5a8cfd8f269493">ByteArray</a> client_data = server_registry.<a class="code hl_function" href="classRegistry.html#a649dbdf578a8498e6282d88a0d81d8d5">convert_comp_entity</a>(</div>
<div class="line">        comp_state.id,</div>
<div class="line">        data,</div>
<div class="line">        id_map</div>
<div class="line">      );</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Send to client</span></div>
<div class="line">      client.send_component(comp_state.id, id_map.at(entity),</div>
<div class="line">client_data);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="aclassRegistry_html_a649dbdf578a8498e6282d88a0d81d8d5"><div class="ttname"><a href="classRegistry.html#a649dbdf578a8498e6282d88a0d81d8d5">Registry::convert_comp_entity</a></div><div class="ttdeci">ByteArray convert_comp_entity(std::string const &amp;id, ByteArray const &amp;comp, std::unordered_map&lt; Entity, Entity &gt; const &amp;map)</div><div class="ttdoc">Convert entity IDs in a serialized event using provided mapping.</div><div class="ttdef"><b>Definition</b> Registry.cpp:292</div></div>
<div class="ttc" id="aclassRegistry_html_aa1f44e83eaea9570fb48f4f20eeeb103"><div class="ttname"><a href="classRegistry.html#aa1f44e83eaea9570fb48f4f20eeeb103">Registry::get_state</a></div><div class="ttdeci">std::vector&lt; ComponentState &gt; get_state()</div><div class="ttdoc">Get the complete ECS state as serialized components.</div><div class="ttdef"><b>Definition</b> Registry.cpp:300</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="structComponentState.html" title="Captures the state of a component type across all entities.">ComponentState</a> structure </dd>
<dd>
<a class="el" href="classRegistry.html#a649dbdf578a8498e6282d88a0d81d8d5" title="Convert entity IDs in a serialized event using provided mapping.">convert_comp_entity()</a> to remap entity IDs in state </dd></dl>

</div>
</div>
<a id="a110e0dd5709b1c0d0838155dbb5ddbbb" name="a110e0dd5709b1c0d0838155dbb5ddbbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110e0dd5709b1c0d0838155dbb5ddbbb">&#9670;&#160;</a></span>get_template()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JsonObject Registry::get_template </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JsonObject const &amp;&#160;</td>
          <td class="paramname"><em>params</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a registered entity template. </p>
<p>Returns a copy of the JSON configuration for the named template. The returned JSON can be modified and passed to <a class="el" href="classEntityLoader.html#a617fd034c346cc4ce7156b4c75b31876">EntityLoader::load_entity()</a> to create an entity instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Template identifier (from <a class="el" href="classRegistry.html#a0eb34875d2a3ade0c6114886e1b41afb" title="Register an entity template for reuse.">add_template()</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy of the template JSON configuration</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Returns empty/default JSON if template not found (prints error) </dd>
<dd>
Returned JSON is a copy - modifications don't affect stored template </dd>
<dd>
<a class="el" href="structUse.html">Use</a> <a class="el" href="classRegistry.html#a0eb34875d2a3ade0c6114886e1b41afb" title="Register an entity template for reuse.">add_template()</a> to update the stored template</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Get template and customize</span></div>
<div class="line"><span class="keyword">auto</span> enemy_config = registry.get_template(<span class="stringliteral">&quot;basic_enemy&quot;</span>);</div>
<div class="line">enemy_config[<span class="stringliteral">&quot;components&quot;</span>][<span class="stringliteral">&quot;Position&quot;</span>][<span class="stringliteral">&quot;x&quot;</span>] = 500;</div>
<div class="line">enemy_config[<span class="stringliteral">&quot;components&quot;</span>][<span class="stringliteral">&quot;Position&quot;</span>][<span class="stringliteral">&quot;y&quot;</span>] = 300;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create entity</span></div>
<div class="line"><a class="code hl_class" href="classEntityLoader.html">EntityLoader</a> loader(registry);</div>
<div class="line">Entity enemy = loader.load_entity(enemy_config);</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">bool</span> has_template(<a class="code hl_class" href="classRegistry.html">Registry</a>&amp; r, <span class="keyword">const</span> std::string&amp; name) {</div>
<div class="line">  <span class="keyword">auto</span> config = r.<a class="code hl_function" href="classRegistry.html#a110e0dd5709b1c0d0838155dbb5ddbbb">get_template</a>(name);</div>
<div class="line">  <span class="keywordflow">return</span> !config.empty();  <span class="comment">// Empty if not found</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> load_entity_safe(<a class="code hl_class" href="classRegistry.html">Registry</a>&amp; r, <span class="keyword">const</span> std::string&amp; template_name) {</div>
<div class="line">  <span class="keywordflow">if</span> (has_template(r, template_name)) {</div>
<div class="line">    <span class="keyword">auto</span> config = r.<a class="code hl_function" href="classRegistry.html#a110e0dd5709b1c0d0838155dbb5ddbbb">get_template</a>(template_name);</div>
<div class="line">    <a class="code hl_class" href="classEntityLoader.html">EntityLoader</a>(r).<a class="code hl_function" href="classEntityLoader.html#a617fd034c346cc4ce7156b4c75b31876">load_entity</a>(config);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Template not found: &quot;</span> &lt;&lt; template_name &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="aclassRegistry_html_a110e0dd5709b1c0d0838155dbb5ddbbb"><div class="ttname"><a href="classRegistry.html#a110e0dd5709b1c0d0838155dbb5ddbbb">Registry::get_template</a></div><div class="ttdeci">JsonObject get_template(std::string const &amp;name, JsonObject const &amp;params={})</div><div class="ttdoc">Retrieve a registered entity template.</div><div class="ttdef"><b>Definition</b> Registry.cpp:267</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRegistry.html#a0eb34875d2a3ade0c6114886e1b41afb" title="Register an entity template for reuse.">add_template()</a> to register templates </dd>
<dd>
<a class="el" href="classEntityLoader.html#a617fd034c346cc4ce7156b4c75b31876">EntityLoader::load_entity()</a> to instantiate entities </dd></dl>

</div>
</div>
<a id="a0ebe63c781a345ce210cfcfa5da3fcae" name="a0ebe63c781a345ce210cfcfa5da3fcae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ebe63c781a345ce210cfcfa5da3fcae">&#9670;&#160;</a></span>has_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Component&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Registry::has_component </td>
          <td>(</td>
          <td class="paramtype">const Entity &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if an entity has all specified components. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Component...</td><td>One or more component types to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The entity to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if entity has all specified components, false otherwise</dd></dl>
<p>Uses fold expression to check all component types in a single call. Returns false if:</p><ul>
<li>Entity ID is out of bounds for any component array</li>
<li>Any component is not present (nullopt)</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (registry.has_component&lt;<a class="code hl_struct" href="structPosition.html">Position</a>&gt;(entity)) {</div>
<div class="line">  <span class="keyword">auto</span>&amp; pos = registry.get_components&lt;<a class="code hl_struct" href="structPosition.html">Position</a>&gt;()[entity];</div>
<div class="line">  <span class="comment">// Use pos</span></div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Check if entity is a moving sprite</span></div>
<div class="line"><span class="keywordflow">if</span> (registry.has_component&lt;<a class="code hl_struct" href="structPosition.html">Position</a>, Velocity, <a class="code hl_struct" href="structSprite.html">Sprite</a>&gt;(entity)) {</div>
<div class="line">  <span class="comment">// Entity has all three components</span></div>
<div class="line">  process_moving_sprite(entity);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a676be837cc2defb394f38b32d664fd30" name="a676be837cc2defb394f38b32d664fd30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676be837cc2defb394f38b32d664fd30">&#9670;&#160;</a></span>init_scene_management()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Registry::init_scene_management </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the scene management system. </p>
<p>Must be called before using any scene-related methods. Sets up internal data structures for scene tracking and filtering.</p>
<dl class="section note"><dt>Note</dt><dd>Call this once during <a class="el" href="classRegistry.html" title="The Registry class is the core of the ECS (Entity-Component-System) architecture.">Registry</a> initialization </dd>
<dd>
Safe to call multiple times (idempotent)</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_class" href="classRegistry.html">Registry</a> registry;</div>
<div class="line">registry.<a class="code hl_function" href="classRegistry.html#a676be837cc2defb394f38b32d664fd30">init_scene_management</a>();  <span class="comment">// Enable scenes</span></div>
<div class="line">registry.<a class="code hl_function" href="classRegistry.html#adfbcd0eed55c7f0d795443ef0f34c855">add_scene</a>(<span class="stringliteral">&quot;menu&quot;</span>, <a class="code hl_enumvalue" href="Scenes_8hpp.html#ab0d98f61608665befb0dc9afa0419e19a18ff74f43da410c5529f7d6fca84f115">SceneState::ACTIVE</a>);</div>
<div class="ttc" id="aclassRegistry_html_a676be837cc2defb394f38b32d664fd30"><div class="ttname"><a href="classRegistry.html#a676be837cc2defb394f38b32d664fd30">Registry::init_scene_management</a></div><div class="ttdeci">void init_scene_management()</div><div class="ttdoc">Initialize the scene management system.</div><div class="ttdef"><b>Definition</b> Registry.cpp:119</div></div>
<div class="ttc" id="aclassRegistry_html_adfbcd0eed55c7f0d795443ef0f34c855"><div class="ttname"><a href="classRegistry.html#adfbcd0eed55c7f0d795443ef0f34c855">Registry::add_scene</a></div><div class="ttdeci">void add_scene(std::string const &amp;scene_name, SceneState state=SceneState::DISABLED)</div><div class="ttdoc">Register a scene with the given name and initial state.</div><div class="ttdef"><b>Definition</b> Registry.cpp:108</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRegistry.html#adfbcd0eed55c7f0d795443ef0f34c855" title="Register a scene with the given name and initial state.">add_scene()</a> to register scenes </dd>
<dd>
<a class="el" href="classRegistry.html#a35e8c1f487a94aaf2752678d814a942a" title="Setup automatic scene management systems.">setup_scene_systems()</a> for automatic scene management </dd></dl>

</div>
</div>
<a id="ac4b33f8cf1890733209cf94c0d15da4f" name="ac4b33f8cf1890733209cf94c0d15da4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4b33f8cf1890733209cf94c0d15da4f">&#9670;&#160;</a></span>is_entity_dying()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Registry::is_entity_dying </td>
          <td>(</td>
          <td class="paramtype">Entity const &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an entity is marked for deletion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The entity to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if entity is in _entities_to_kill set, false otherwise</dd></dl>
<p>Useful to avoid processing entities that will be deleted soon. Entity remains accessible but should be treated as "dead".</p>
<div class="fragment"><div class="line">registry.kill_entity(enemy);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (!registry.is_entity_dying(enemy)) {</div>
<div class="line">  <span class="comment">// Safe to process</span></div>
<div class="line">  process_enemy(enemy);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa173e9399b055aa64d39a86ebd0d90b9" name="aa173e9399b055aa64d39a86ebd0d90b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa173e9399b055aa64d39a86ebd0d90b9">&#9670;&#160;</a></span>is_in_current_cene()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Registry::is_in_current_cene </td>
          <td>(</td>
          <td class="paramtype">Entity&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad53c13e55864ae8333a766563d8167cc" name="ad53c13e55864ae8333a766563d8167cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad53c13e55864ae8333a766563d8167cc">&#9670;&#160;</a></span>is_in_main_scene()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Registry::is_in_main_scene </td>
          <td>(</td>
          <td class="paramtype">Entity&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6dea4f9463f5e582337406da60b721e6" name="a6dea4f9463f5e582337406da60b721e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dea4f9463f5e582337406da60b721e6">&#9670;&#160;</a></span>is_scene_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Registry::is_scene_active </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>scene_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a scene is currently active. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scene_name</td><td>Name of the scene to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the scene is active, false otherwise </dd></dl>

</div>
</div>
<a id="a9f8e76e4f67a4e33dd7273d065d6be7a" name="a9f8e76e4f67a4e33dd7273d065d6be7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8e76e4f67a4e33dd7273d065d6be7a">&#9670;&#160;</a></span>kill_entity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Registry::kill_entity </td>
          <td>(</td>
          <td class="paramtype">Entity const &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks an entity for deletion. </p>
<p>Queues an entity to be destroyed at the end of the current frame. Actual deletion occurs during <a class="el" href="classRegistry.html#a2cf00a9ea3b232b551de02598cbc7756" title="Deletes all entities marked for killing.">process_entity_deletions()</a>, typically called at the end of <a class="el" href="classRegistry.html#ae484ce9b1fdb58e76997409a74227701" title="Registers a system function to run every frame.">run_systems()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The entity to kill</td></tr>
  </table>
  </dd>
</dl>
<p>Deferred deletion prevents iterator invalidation and mid-system crashes:</p><ul>
<li>Entity added to _entities_to_kill set</li>
<li>Systems can still access the entity this frame</li>
<li>Components removed at frame end</li>
<li>Entity ID recycled for future use</li>
</ul>
<p>Multiple kills of same entity are safe (set deduplicates).</p>
<dl class="section warning"><dt>Warning</dt><dd>Entity remains accessible until <a class="el" href="classRegistry.html#a2cf00a9ea3b232b551de02598cbc7756" title="Deletes all entities marked for killing.">process_entity_deletions()</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Killing already-dead entity is safe (no-op)</dd></dl>
<div class="fragment"><div class="line">registry.kill_entity(bullet);</div>
<div class="line"><span class="comment">// Bullet still exists here</span></div>
<div class="line"> </div>
<div class="line">registry.run_systems();  <span class="comment">// Calls process_entity_deletions()</span></div>
<div class="line"><span class="comment">// Bullet deleted now</span></div>
</div><!-- fragment --><div class="fragment"><div class="line">registry.add_system&lt;<a class="code hl_struct" href="structPosition.html">Position</a>, <a class="code hl_struct" href="structHealth.html">Health</a>&gt;([](<a class="code hl_class" href="classRegistry.html">Registry</a>&amp; r, <span class="keyword">auto</span>&amp; pos, <span class="keyword">auto</span>&amp; hp)</div>
<div class="line">{ <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; [e, p, h] : <a class="code hl_class" href="classZipper.html">Zipper</a>(pos, hp)) { <span class="keywordflow">if</span> (h.current &lt;= 0) {</div>
<div class="line">      r.kill_entity(e.entity());  <span class="comment">// Safe - deferred deletion</span></div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// All entities still valid during iteration</span></div>
<div class="line">});</div>
</div><!-- fragment --><div class="fragment"><div class="line">registry.kill_entity(enemy);</div>
<div class="line"><span class="keywordflow">if</span> (registry.is_entity_dying(enemy)) {</div>
<div class="line">  <span class="comment">// Don&#39;t interact with dying entity</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRegistry.html#a2cf00a9ea3b232b551de02598cbc7756" title="Deletes all entities marked for killing.">process_entity_deletions()</a> for actual deletion </dd>
<dd>
<a class="el" href="classRegistry.html#ac4b33f8cf1890733209cf94c0d15da4f" title="Checks if an entity is marked for deletion.">is_entity_dying()</a> to check pending deletion </dd></dl>

</div>
</div>
<a id="a348496c10466004c5b009e1534202f5d" name="a348496c10466004c5b009e1534202f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348496c10466004c5b009e1534202f5d">&#9670;&#160;</a></span>pop_scene()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Registry::pop_scene </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>scene_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop a scene from the active scene stack. </p>
<p>Deactivates a scene and removes it from the scene stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scene_name</td><td>Name of the scene to pop </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cf00a9ea3b232b551de02598cbc7756" name="a2cf00a9ea3b232b551de02598cbc7756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf00a9ea3b232b551de02598cbc7756">&#9670;&#160;</a></span>process_entity_deletions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Registry::process_entity_deletions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes all entities marked for killing. </p>
<p>Processes the _entities_to_kill set, removing all components from those entities and recycling their IDs.</p>
<p>For each entity in _entities_to_kill:</p><ol type="1">
<li>Call delete function for every registered component type</li>
<li>Add entity ID to _dead_entities queue for recycling</li>
<li>Clear _entities_to_kill set</li>
</ol>
<p>This is automatically called at the end of <a class="el" href="classRegistry.html#ae484ce9b1fdb58e76997409a74227701" title="Registers a system function to run every frame.">run_systems()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Generally called automatically - manual use rarely needed </dd>
<dd>
Safe to call multiple times (clears empty set) <div class="fragment"><div class="line"><span class="comment">// Batch kill entities</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> enemy : enemies_to_remove) {</div>
<div class="line">  registry.kill_entity(enemy);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Force immediate deletion (unusual)</span></div>
<div class="line">registry.process_entity_deletions();</div>
<div class="line"><span class="comment">// Entities deleted now instead of at frame end</span></div>
</div><!-- fragment --></dd></dl>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (game_running) {</div>
<div class="line">  registry.run_systems();</div>
<div class="line">  <span class="comment">// process_entity_deletions() called automatically here</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRegistry.html#a9f8e76e4f67a4e33dd7273d065d6be7a" title="Marks an entity for deletion.">kill_entity()</a> to mark entities for deletion </dd>
<dd>
<a class="el" href="classRegistry.html#ae484ce9b1fdb58e76997409a74227701" title="Registers a system function to run every frame.">run_systems()</a> which calls this automatically </dd></dl>

</div>
</div>
<a id="a42a2427184d9f6bcfef9a5addfe9511e" name="a42a2427184d9f6bcfef9a5addfe9511e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a2427184d9f6bcfef9a5addfe9511e">&#9670;&#160;</a></span>push_scene()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Registry::push_scene </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>scene_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push a scene onto the active scene stack. </p>
<p>Activates a scene and adds it to the top of the scene stack. This is useful for overlay scenes like pause menus or popups.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scene_name</td><td>Name of the scene to push </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a529bdf9002188825f7b03f33b2991624" name="a529bdf9002188825f7b03f33b2991624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a529bdf9002188825f7b03f33b2991624">&#9670;&#160;</a></span>register_binding()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptcomponent.html">component</a> ComponentType, typename <a class="el" href="IoEvents_8hpp.html#a9479d299e1852e6140dcca1f405868aba21f40778b7db9343a6ca75ec2c41ccce">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Registry::register_binding </td>
          <td>(</td>
          <td class="paramtype">Entity&#160;</td>
          <td class="paramname"><em>entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>source_hook</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a dynamic binding between component fields. </p>
<p>Creates a live connection where a target field automatically updates to match a source field every frame. Used for data-driven behaviors like followers, turrets tracking targets, or <a class="el" href="classUI.html">UI</a> elements following entities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ComponentType</td><td>Type of component containing the target field </td></tr>
    <tr><td class="paramname">T</td><td>Type of the field being bound </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity</td><td>Entity owning the target component </td></tr>
    <tr><td class="paramname">field_name</td><td>Name of the target field (must be hookable) </td></tr>
    <tr><td class="paramname">source_hook</td><td>Source identifier in format "scope:ComponentName:fieldName"<ul>
<li>"self:ComponentName:fieldName" - same entity binding</li>
<li>"global:Name:fieldName" - global singleton binding</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Creates a Binding struct containing:</p><ul>
<li>updater: Lambda that copies source value to target field each frame</li>
<li>serializer: Lambda that serializes target component for network sync</li>
</ul>
<p>The binding is executed every frame during <a class="el" href="classRegistry.html#ae99ff1a3c4f750cba3bb80534f4295c4" title="Updates all registered dynamic bindings.">update_bindings()</a>.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classTarget.html">Target</a> component type must be hookable (use HOOKABLE macro) </dd>
<dd>
Source component must exist and be hookable </dd>
<dd>
Binding survives until <a class="el" href="classRegistry.html#ab44989c0361996ad2c4aefbf4636b664" title="Removes all registered bindings.">clear_bindings()</a> or entity deletion </dd>
<dd>
Typically called automatically during component JSON construction</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structFollower.html">Follower</a> {</div>
<div class="line">  <a class="code hl_class" href="classVector2D.html">Vector2D</a> target_pos;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_struct" href="structFollower.html">Follower</a>(<a class="code hl_class" href="classRegistry.html">Registry</a>&amp; r, JsonObject <span class="keyword">const</span>&amp; obj, Entity self) {</div>
<div class="line">    <span class="comment">// JSON: {&quot;target_pos&quot;: &quot;#self:Position:pos&quot;}</span></div>
<div class="line">    target_pos = get_value&lt;Follower, Vector2D&gt;(</div>
<div class="line">      r, obj, self, <span class="stringliteral">&quot;target_pos&quot;</span></div>
<div class="line">    ).value_or(<a class="code hl_class" href="classVector2D.html">Vector2D</a>{0, 0});</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// register_binding called internally by get_value</span></div>
<div class="line">    <span class="comment">// Creates: Follower.target_pos &lt;- self.Position.pos binding</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_define" href="HookMacros_8hpp.html#a8f0cb5d5dff2b9cbbd63e1e50cc30e6a">HOOKABLE</a>(<a class="code hl_struct" href="structFollower.html">Follower</a>, <a class="code hl_define" href="HookMacros_8hpp.html#a64db554aa76425e63b60d0fd6ccb1e26">HOOK</a>(target_pos))</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Every frame:</span></div>
<div class="line"><span class="comment">// 1. Entity Position moves to new location</span></div>
<div class="line"><span class="comment">// 2. update_bindings() executes</span></div>
<div class="line"><span class="comment">// 3. Follower.target_pos = Position.pos (automatic!)</span></div>
<div class="ttc" id="aHookMacros_8hpp_html_a64db554aa76425e63b60d0fd6ccb1e26"><div class="ttname"><a href="HookMacros_8hpp.html#a64db554aa76425e63b60d0fd6ccb1e26">HOOK</a></div><div class="ttdeci">#define HOOK(var)</div><div class="ttdoc">Registers a component field using its variable name as the hook key.</div><div class="ttdef"><b>Definition</b> HookMacros.hpp:179</div></div>
<div class="ttc" id="aHookMacros_8hpp_html_a8f0cb5d5dff2b9cbbd63e1e50cc30e6a"><div class="ttname"><a href="HookMacros_8hpp.html#a8f0cb5d5dff2b9cbbd63e1e50cc30e6a">HOOKABLE</a></div><div class="ttdeci">#define HOOKABLE(type,...)</div><div class="ttdoc">Makes a component type hookable by generating a static hook map.</div><div class="ttdef"><b>Definition</b> HookMacros.hpp:233</div></div>
<div class="ttc" id="astructFollower_html"><div class="ttname"><a href="structFollower.html">Follower</a></div><div class="ttdef"><b>Definition</b> Follower.hpp:11</div></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">struct </span>HealthBar {</div>
<div class="line">  <span class="keywordtype">int</span> max_value;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_define" href="HookMacros_8hpp.html#a8f0cb5d5dff2b9cbbd63e1e50cc30e6a">HOOKABLE</a>(HealthBar, <a class="code hl_define" href="HookMacros_8hpp.html#a64db554aa76425e63b60d0fd6ccb1e26">HOOK</a>(max_value))</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Bind UI to global game config</span></div>
<div class="line">registry.register_binding&lt;HealthBar, <span class="keywordtype">int</span>&gt;(</div>
<div class="line">  health_bar_entity,</div>
<div class="line">  <span class="stringliteral">&quot;max_value&quot;</span>,</div>
<div class="line">  <span class="stringliteral">&quot;global:GameConfig:maxHealth&quot;</span></div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Health bar automatically reflects global config changes</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRegistry.html#ae99ff1a3c4f750cba3bb80534f4295c4" title="Updates all registered dynamic bindings.">update_bindings()</a> which executes bindings </dd>
<dd>
<a class="el" href="Hooks_8hpp.html#a9eab5392562ddc7b99520a786e6b230b" title="Gets a value and registers a dynamic binding for auto-updates.">get_value()</a> which calls this for # hooks </dd>
<dd>
<a class="el" href="HookMacros_8hpp.html#a8f0cb5d5dff2b9cbbd63e1e50cc30e6a" title="Makes a component type hookable by generating a static hook map.">HOOKABLE</a> macro to make components bindable </dd>
<dd>
<a class="el" href="Hooks_8hpp.html" title="Hook resolution and JSON value extraction functions.">Hooks.hpp</a> for hook syntax details </dd></dl>

</div>
</div>
<a id="aa3c7728231c60cf0e6742d693aa50bbf" name="aa3c7728231c60cf0e6742d693aa50bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c7728231c60cf0e6742d693aa50bbf">&#9670;&#160;</a></span>register_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptcomponent.html">component</a> Component&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseArray.html">SparseArray</a>&lt; Component &gt; &amp; Registry::register_component </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>string_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a bytable component type with a string identifier. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Component</td><td>The type of the component to register (must satisfy bytable concept). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string_id</td><td>The string identifier for this component type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SparseArray&lt;Component&gt;&amp; A reference to the sparse array of the registered component type.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Must be called before using the component type </dd>
<dd>
String ID must be unique across all component types </dd>
<dd>
Registration is idempotent - re-registering replaces existing </dd></dl>
<dl class="section see"><dt>See also</dt><dd>// TODO: Mention Macros </dd></dl>

</div>
</div>
<a id="af774fbeb95691f112557590f04e5f150" name="af774fbeb95691f112557590f04e5f150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af774fbeb95691f112557590f04e5f150">&#9670;&#160;</a></span>register_global_hook()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="concepthookable.html">hookable</a> T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Registry::register_global_hook </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Entity const &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structRegister.html">Register</a> a global hook for singleton components. </p>
<p>Registers a component hook accessible via the "global" scope in the new hook syntax. Global hooks are used for singleton components like GameConfig, LevelSettings, etc. that should be accessible from any entity.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Component type (must satisfy hookable concept) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Global hook identifier (e.g., "GameConfig") </td></tr>
    <tr><td class="paramname">e</td><td>Entity containing the singleton component</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="structUse.html">Use</a> this for singletons/global configuration components </dd>
<dd>
Accessible via #global:Name:field syntax</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Register global game config</span></div>
<div class="line">Entity config = registry.spawn_entity();</div>
<div class="line">registry.add_component&lt;GameConfig&gt;(config);</div>
<div class="line">registry.register_global_hook&lt;GameConfig&gt;(<span class="stringliteral">&quot;GameConfig&quot;</span>, config);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now accessible from any entity:</span></div>
<div class="line"><span class="comment">// {&quot;speed&quot;: &quot;#global:GameConfig:maxSpeed&quot;}</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a988dbbf41e2d34202090c4b47a17d4f7" name="a988dbbf41e2d34202090c4b47a17d4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988dbbf41e2d34202090c4b47a17d4f7">&#9670;&#160;</a></span>register_hook()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="concepthookable.html">hookable</a> T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Registry::register_hook </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Entity const &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structRegister.html">Register</a> component hooks for runtime field access. </p>
<p>Makes the specified entity's component fields accessible via string names. The component type must be hookable (declared with HOOKABLE macro).</p>
<p>After registration, <a class="el" href="classRegistry.html#a3c5b1d39982cf8c8a5159f048478faf9" title="Retrieve a reference to a hooked component field.">get_hooked_value()</a> can retrieve field values using the hook name and field name. This enables JSON configuration to reference runtime values with syntax like "%hookname:fieldname".</p>
<p>The hook persists until the <a class="el" href="classRegistry.html" title="The Registry class is the core of the ECS (Entity-Component-System) architecture.">Registry</a> is destroyed or the entity is deleted. Registering the same name again overwrites the previous registration.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Component type (must satisfy hookable concept) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Unique identifier for this hook (user-defined) </td></tr>
    <tr><td class="paramname">e</td><td>Entity containing the component</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Component must have <a class="el" href="HookMacros_8hpp.html#a8f0cb5d5dff2b9cbbd63e1e50cc30e6a" title="Makes a component type hookable by generating a static hook map.">HOOKABLE()</a> declaration </dd>
<dd>
Hook name should be unique within the <a class="el" href="classRegistry.html" title="The Registry class is the core of the ECS (Entity-Component-System) architecture.">Registry</a> </dd>
<dd>
Entity must have the component when accessed</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Component with hookable fields</span></div>
<div class="line"><span class="keyword">struct </span>PlayerConfig {</div>
<div class="line">  <span class="keywordtype">float</span> max_speed = 100.0f;</div>
<div class="line">  <span class="keywordtype">int</span> max_health = 100;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_define" href="HookMacros_8hpp.html#a8f0cb5d5dff2b9cbbd63e1e50cc30e6a">HOOKABLE</a>(PlayerConfig,</div>
<div class="line">           <a class="code hl_define" href="HookMacros_8hpp.html#a64db554aa76425e63b60d0fd6ccb1e26">HOOK</a>(max_speed),</div>
<div class="line">           <a class="code hl_define" href="HookMacros_8hpp.html#a64db554aa76425e63b60d0fd6ccb1e26">HOOK</a>(max_health))</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Register hook for global config entity</span></div>
<div class="line">Entity config_entity = registry.spawn_entity();</div>
<div class="line">registry.add_component&lt;PlayerConfig&gt;(config_entity);</div>
<div class="line">registry.register_hook&lt;PlayerConfig&gt;(<span class="stringliteral">&quot;PlayerConfig&quot;</span>, config_entity);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now JSON can reference these values</span></div>
<div class="line"><span class="comment">// {&quot;speed&quot;: &quot;%PlayerConfig:max_speed&quot;}  // Uses hooked value</span></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Register multiple player entities</span></div>
<div class="line">Entity p1 = registry.spawn_entity();</div>
<div class="line">Entity p2 = registry.spawn_entity();</div>
<div class="line">registry.add_component&lt;<a class="code hl_struct" href="structPosition.html">Position</a>&gt;(p1, 10.0f, 20.0f);</div>
<div class="line">registry.add_component&lt;<a class="code hl_struct" href="structPosition.html">Position</a>&gt;(p2, 50.0f, 60.0f);</div>
<div class="line"> </div>
<div class="line">registry.register_hook&lt;<a class="code hl_struct" href="structPosition.html">Position</a>&gt;(<span class="stringliteral">&quot;player1&quot;</span>, p1);</div>
<div class="line">registry.register_hook&lt;<a class="code hl_struct" href="structPosition.html">Position</a>&gt;(<span class="stringliteral">&quot;player2&quot;</span>, p2);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Access specific player positions</span></div>
<div class="line"><span class="keyword">auto</span> p1_x = registry.get_hooked_value&lt;<span class="keywordtype">float</span>&gt;(<span class="stringliteral">&quot;player1&quot;</span>, <span class="stringliteral">&quot;x&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> p2_x = registry.get_hooked_value&lt;<span class="keywordtype">float</span>&gt;(<span class="stringliteral">&quot;player2&quot;</span>, <span class="stringliteral">&quot;x&quot;</span>);</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Register player as target for AI</span></div>
<div class="line">Entity player = spawn_player(registry);</div>
<div class="line">registry.register_hook&lt;<a class="code hl_struct" href="structPosition.html">Position</a>&gt;(<span class="stringliteral">&quot;player&quot;</span>, player);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Enemy JSON can reference player position</span></div>
<div class="line"><span class="comment">// {</span></div>
<div class="line"><span class="comment">//   &quot;enemy&quot;: {</span></div>
<div class="line"><span class="comment">//     &quot;components&quot;: {</span></div>
<div class="line"><span class="comment">//       &quot;AI&quot;: {</span></div>
<div class="line"><span class="comment">//         &quot;target&quot;: &quot;#player:pos&quot;  // Binds to player position</span></div>
<div class="line"><span class="comment">//       }</span></div>
<div class="line"><span class="comment">//     }</span></div>
<div class="line"><span class="comment">//   }</span></div>
<div class="line"><span class="comment">// }</span></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">struct </span>GameConfig {</div>
<div class="line">  <span class="keywordtype">float</span> gravity = 9.8f;</div>
<div class="line">  <span class="keywordtype">float</span> friction = 0.95f;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_define" href="HookMacros_8hpp.html#a8f0cb5d5dff2b9cbbd63e1e50cc30e6a">HOOKABLE</a>(GameConfig, <a class="code hl_define" href="HookMacros_8hpp.html#a64db554aa76425e63b60d0fd6ccb1e26">HOOK</a>(gravity), <a class="code hl_define" href="HookMacros_8hpp.html#a64db554aa76425e63b60d0fd6ccb1e26">HOOK</a>(friction))</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create global config entity</span></div>
<div class="line">Entity config = registry.spawn_entity();</div>
<div class="line">registry.add_component&lt;GameConfig&gt;(config);</div>
<div class="line">registry.register_hook&lt;GameConfig&gt;(<span class="stringliteral">&quot;GameConfig&quot;</span>, config);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// All entity configs can reference global settings</span></div>
<div class="line"><span class="comment">// {&quot;friction&quot;: &quot;%GameConfig:friction&quot;}</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRegistry.html#a3c5b1d39982cf8c8a5159f048478faf9" title="Retrieve a reference to a hooked component field.">get_hooked_value()</a> to retrieve field values </dd>
<dd>
<a class="el" href="HookMacros_8hpp.html#a8f0cb5d5dff2b9cbbd63e1e50cc30e6a" title="Makes a component type hookable by generating a static hook map.">HOOKABLE()</a> macro to declare <a class="el" href="concepthookable.html" title="Requires a type to provide a static hook_map() method.">hookable</a> components </dd>
<dd>
<a class="el" href="classRegistry.html#a529bdf9002188825f7b03f33b2991624" title="Registers a dynamic binding between component fields.">register_binding()</a> which uses hooks for dynamic data binding </dd></dl>

</div>
</div>
<a id="aa3aabe22621e394e0e17f2f2b35a59c8" name="aa3aabe22621e394e0e17f2f2b35a59c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3aabe22621e394e0e17f2f2b35a59c8">&#9670;&#160;</a></span>remove_all_scenes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Registry::remove_all_scenes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deactivate all scenes. </p>
<p>Sets all scenes to DISABLED state. No entities will be processed by systems until scenes are reactivated with <a class="el" href="classRegistry.html#ad1c9d136cf9da966ef0977d3c698a963" title="Activate a scene, making its entities visible to systems.">set_current_scene()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Does not delete scenes - they can be reactivated </dd>
<dd>
Does not delete entities </dd>
<dd>
Useful for complete state resets</dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> restart_game(<a class="code hl_class" href="classRegistry.html">Registry</a>&amp; r) {</div>
<div class="line">  r.<a class="code hl_function" href="classRegistry.html#aa3aabe22621e394e0e17f2f2b35a59c8">remove_all_scenes</a>();  <span class="comment">// Disable everything</span></div>
<div class="line">  r.<a class="code hl_function" href="classRegistry.html#ad1c9d136cf9da966ef0977d3c698a963">set_current_scene</a>(<span class="stringliteral">&quot;main_menu&quot;</span>);</div>
<div class="ttc" id="aclassRegistry_html_aa3aabe22621e394e0e17f2f2b35a59c8"><div class="ttname"><a href="classRegistry.html#aa3aabe22621e394e0e17f2f2b35a59c8">Registry::remove_all_scenes</a></div><div class="ttdeci">void remove_all_scenes()</div><div class="ttdoc">Deactivate all scenes.</div><div class="ttdef"><b>Definition</b> Registry.cpp:229</div></div>
<div class="ttc" id="aclassRegistry_html_ad1c9d136cf9da966ef0977d3c698a963"><div class="ttname"><a href="classRegistry.html#ad1c9d136cf9da966ef0977d3c698a963">Registry::set_current_scene</a></div><div class="ttdeci">void set_current_scene(std::string const &amp;scene_name)</div><div class="ttdoc">Activate a scene, making its entities visible to systems.</div><div class="ttdef"><b>Definition</b> Registry.cpp:214</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae83c694e0e30125b850edcc343406b76" name="ae83c694e0e30125b850edcc343406b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae83c694e0e30125b850edcc343406b76">&#9670;&#160;</a></span>remove_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Component &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Registry::remove_component </td>
          <td>(</td>
          <td class="paramtype">Entity const &amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a component from an entity. </p>
<p>Erases the component at the entity's index in the component storage array. If the entity doesn't have this component, this is a no-op.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Component</td><td>The component type to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The entity to remove the component from</td></tr>
  </table>
  </dd>
</dl>
<p>Sets the <a class="el" href="classSparseArray.html" title="A sparse array implementation that stores components in an optional vector.">SparseArray</a> slot to std::nullopt. The entity remains valid and can still have other component types.</p>
<dl class="section note"><dt>Note</dt><dd>Safe to call on entities without the component </dd>
<dd>
Component type must be registered (or bad_any_cast thrown) </dd>
<dd>
Does not kill the entity - only removes one component</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Remove velocity to stop movement</span></div>
<div class="line">registry.remove_component&lt;Velocity&gt;(entity);</div>
<div class="line"><span class="comment">// Entity still exists with other components</span></div>
</div><!-- fragment --><div class="fragment"><div class="line">registry.add_system&lt;<a class="code hl_struct" href="structPosition.html">Position</a>, <a class="code hl_struct" href="structSprite.html">Sprite</a>&gt;([](<a class="code hl_class" href="classRegistry.html">Registry</a>&amp; r, <span class="keyword">auto</span>&amp; pos, <span class="keyword">auto</span>&amp; spr)</div>
<div class="line">{ <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; [e, p, s] : <a class="code hl_class" href="classZipper.html">Zipper</a>(pos, spr)) { <span class="keywordflow">if</span> (p.x &lt; 0 || p.x &gt;</div>
<div class="line">screen_width) {</div>
<div class="line">      <span class="comment">// Remove offscreen sprites to save rendering</span></div>
<div class="line">      r.remove_component&lt;<a class="code hl_struct" href="structSprite.html">Sprite</a>&gt;(e.entity());</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">});</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRegistry.html#a9f8e76e4f67a4e33dd7273d065d6be7a" title="Marks an entity for deletion.">kill_entity()</a> to remove all components and delete entity </dd>
<dd>
<a class="el" href="classRegistry.html#a9990d86dfe7f90e314f8e93773b307d4" title="Adds a component to an entity by moving.">add_component()</a> to add components back </dd></dl>

</div>
</div>
<a id="a936cd3eebe707ee32e2aac62eb079404" name="a936cd3eebe707ee32e2aac62eb079404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a936cd3eebe707ee32e2aac62eb079404">&#9670;&#160;</a></span>remove_current_scene()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Registry::remove_current_scene </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>scene_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deactivate a specific scene. </p>
<p>Sets the scene to DISABLED state. Entities in this scene will no longer be processed by systems until the scene is reactivated with <a class="el" href="classRegistry.html#ad1c9d136cf9da966ef0977d3c698a963" title="Activate a scene, making its entities visible to systems.">set_current_scene()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scene_name</td><td>Name of the scene to deactivate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Safe to call with non-existent scene names (no-op) </dd>
<dd>
Does not delete the scene or its entities </dd>
<dd>
<a class="el" href="structScene.html" title="Component that associates an entity with a specific scene.">Scene</a> can be reactivated later with <a class="el" href="classRegistry.html#ad1c9d136cf9da966ef0977d3c698a963" title="Activate a scene, making its entities visible to systems.">set_current_scene()</a></dd></dl>
<div class="fragment"><div class="line"><span class="comment">// User clicks &quot;Start Game&quot;</span></div>
<div class="line">registry.remove_current_scene(<span class="stringliteral">&quot;main_menu&quot;</span>);</div>
<div class="line">registry.set_current_scene(<span class="stringliteral">&quot;gameplay&quot;</span>);</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">void</span> toggle_pause(<a class="code hl_class" href="classRegistry.html">Registry</a>&amp; r, <span class="keywordtype">bool</span>&amp; paused) {</div>
<div class="line">  <span class="keywordflow">if</span> (paused) {</div>
<div class="line">    r.<a class="code hl_function" href="classRegistry.html#a936cd3eebe707ee32e2aac62eb079404">remove_current_scene</a>(<span class="stringliteral">&quot;pause_menu&quot;</span>);</div>
<div class="line">    paused = <span class="keyword">false</span>;</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    r.<a class="code hl_function" href="classRegistry.html#ad1c9d136cf9da966ef0977d3c698a963">set_current_scene</a>(<span class="stringliteral">&quot;pause_menu&quot;</span>);</div>
<div class="line">    paused = <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="aclassRegistry_html_a936cd3eebe707ee32e2aac62eb079404"><div class="ttname"><a href="classRegistry.html#a936cd3eebe707ee32e2aac62eb079404">Registry::remove_current_scene</a></div><div class="ttdeci">void remove_current_scene(std::string const &amp;scene_name)</div><div class="ttdoc">Deactivate a specific scene.</div><div class="ttdef"><b>Definition</b> Registry.cpp:224</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRegistry.html#ad1c9d136cf9da966ef0977d3c698a963" title="Activate a scene, making its entities visible to systems.">set_current_scene()</a> to reactivate </dd>
<dd>
<a class="el" href="classRegistry.html#aa3aabe22621e394e0e17f2f2b35a59c8" title="Deactivate all scenes.">remove_all_scenes()</a> to deactivate all scenes </dd></dl>

</div>
</div>
<a id="ae484ce9b1fdb58e76997409a74227701" name="ae484ce9b1fdb58e76997409a74227701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae484ce9b1fdb58e76997409a74227701">&#9670;&#160;</a></span>run_systems()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Registry::run_systems </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEventManager.html">EventManager</a> &amp;&#160;</td>
          <td class="paramname"><em>em</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a system function to run every frame. </p>
<p>Adds a system to the execution pipeline. Systems are functions that process entities with specific component combinations. They run in priority order during <a class="el" href="classRegistry.html#ae484ce9b1fdb58e76997409a74227701" title="Registers a system function to run every frame.">run_systems()</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Components</td><td>Component types the system operates on </td></tr>
    <tr><td class="paramname">Function</td><td><a class="el" href="classSystem.html" title="Encapsulates a system function with priority-based execution ordering.">System</a> function type (deduced) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The system function - signature: void(Registry&amp;,
SparseArray&lt;Component&gt;&amp;...) </td></tr>
    <tr><td class="paramname">priority</td><td>Execution priority (lower = earlier, default: 0)</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="classSystem.html" title="Encapsulates a system function with priority-based execution ordering.">System</a> execution:</p><ol type="1">
<li>Systems stored in priority order in _frequent_systems</li>
<li><a class="el" href="classRegistry.html#ae484ce9b1fdb58e76997409a74227701" title="Registers a system function to run every frame.">run_systems()</a> calls each system with registry and component arrays</li>
<li><a class="el" href="classSystem.html" title="Encapsulates a system function with priority-based execution ordering.">System</a> iterates entities (typically using <a class="el" href="classZipper.html" title="Range adapter that simultaneously iterates over multiple Comps.">Zipper</a>)</li>
</ol>
<p>Priority ordering:</p><ul>
<li>Lower values run first (e.g., priority 0 before priority 100)</li>
<li>Same priority = insertion order</li>
<li><a class="el" href="structUse.html">Use</a> priority to enforce dependencies (physics before rendering)</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Systems run every frame in <a class="el" href="classRegistry.html#ae484ce9b1fdb58e76997409a74227701" title="Registers a system function to run every frame.">run_systems()</a> </dd>
<dd>
Component types must be registered before adding systems </dd>
<dd>
Systems are copyable - lambda captures must be copy-safe</dd></dl>
<div class="fragment"><div class="line">registry.add_system&lt;<a class="code hl_struct" href="structPosition.html">Position</a>, Velocity&gt;(</div>
<div class="line">  [](<a class="code hl_class" href="classRegistry.html">Registry</a>&amp; r, <span class="keyword">auto</span>&amp; positions, <span class="keyword">auto</span>&amp; velocities) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; [pos, vel] : <a class="code hl_class" href="classZipper.html">Zipper</a>(positions, velocities)) {</div>
<div class="line">      pos.x += vel.speed.x * r.clock().delta_time();</div>
<div class="line">      pos.y += vel.speed.y * r.clock().delta_time();</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">);</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Physics runs first (priority 10)</span></div>
<div class="line">registry.add_system&lt;<a class="code hl_struct" href="structPosition.html">Position</a>, Velocity&gt;(</div>
<div class="line">  [](<a class="code hl_class" href="classRegistry.html">Registry</a>&amp; r, <span class="keyword">auto</span>&amp; pos, <span class="keyword">auto</span>&amp; vel) {</div>
<div class="line">    <span class="comment">// Update positions</span></div>
<div class="line">  },</div>
<div class="line">  10</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Collision detection after physics (priority 20)</span></div>
<div class="line">registry.add_system&lt;<a class="code hl_struct" href="structPosition.html">Position</a>, <a class="code hl_struct" href="structCollidable.html">Collidable</a>&gt;(</div>
<div class="line">  [](<a class="code hl_class" href="classRegistry.html">Registry</a>&amp; r, <span class="keyword">auto</span>&amp; pos, <span class="keyword">auto</span>&amp; col) {</div>
<div class="line">    <span class="comment">// Check collisions</span></div>
<div class="line">  },</div>
<div class="line">  20</div>
<div class="line">);</div>
<div class="ttc" id="astructCollidable_html"><div class="ttname"><a href="structCollidable.html">Collidable</a></div><div class="ttdef"><b>Definition</b> Collidable.hpp:22</div></div>
</div><!-- fragment --><div class="fragment"><div class="line">registry.add_system&lt;<a class="code hl_struct" href="structPosition.html">Position</a>, Velocity, <a class="code hl_struct" href="structSprite.html">Sprite</a>, <a class="code hl_struct" href="structHealth.html">Health</a>&gt;(</div>
<div class="line">  [](<a class="code hl_class" href="classRegistry.html">Registry</a>&amp; r, <span class="keyword">auto</span>&amp; pos, <span class="keyword">auto</span>&amp; vel, <span class="keyword">auto</span>&amp; spr, <span class="keyword">auto</span>&amp; hp) {</div>
<div class="line">    <span class="comment">// Zipper automatically filters to entities with ALL components</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; [p, v, s, h] : <a class="code hl_class" href="classZipper.html">Zipper</a>(pos, vel, spr, hp)) {</div>
<div class="line">      <span class="comment">// Only entities with all 4 components</span></div>
<div class="line">      <span class="keywordflow">if</span> (h.current &lt;= h.max * 0.3f) {</div>
<div class="line">        s.tint = Color::RED;  <span class="comment">// Low health = red tint</span></div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">);</div>
</div><!-- fragment --><div class="fragment"><div class="line">registry.add_system&lt;<a class="code hl_struct" href="structPosition.html">Position</a>, <a class="code hl_struct" href="structHealth.html">Health</a>&gt;(</div>
<div class="line">  [](<a class="code hl_class" href="classRegistry.html">Registry</a>&amp; r, <span class="keyword">auto</span>&amp; positions, <span class="keyword">auto</span>&amp; healths) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; [entity_wrapper, pos, hp] : IndexedZipper(positions,</div>
<div class="line">healths)) { <span class="keywordflow">if</span> (hp.current &lt;= 0) { r.kill_entity(entity_wrapper.entity());</div>
<div class="line"><span class="comment">// Access entity ID</span></div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">);</div>
</div><!-- fragment --><div class="fragment"><div class="line">registry.add_system&lt;<a class="code hl_struct" href="structPosition.html">Position</a>, Velocity&gt;(</div>
<div class="line">  [](<a class="code hl_class" href="classRegistry.html">Registry</a>&amp; r, <span class="keyword">auto</span>&amp; pos, <span class="keyword">auto</span>&amp; vel) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; [e, p, v] : IndexedZipper(pos, vel)) {</div>
<div class="line">      <span class="keywordflow">if</span> (p.x &lt; 0 || p.x &gt; screen_width) {</div>
<div class="line">        r.emit&lt;EntityOffscreenEvent&gt;(e.entity(), p.x, p.y);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRegistry.html#ae484ce9b1fdb58e76997409a74227701" title="Registers a system function to run every frame.">run_systems()</a> to execute all registered systems </dd>
<dd>
<a class="el" href="classZipper.html" title="Range adapter that simultaneously iterates over multiple Comps.">Zipper</a> for entity iteration </dd>
<dd>
<a class="el" href="classSystem.html" title="Encapsulates a system function with priority-based execution ordering.">System</a> class for wrapper details </dd></dl>

</div>
</div>
<a id="ad1c9d136cf9da966ef0977d3c698a963" name="ad1c9d136cf9da966ef0977d3c698a963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c9d136cf9da966ef0977d3c698a963">&#9670;&#160;</a></span>set_current_scene()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Registry::set_current_scene </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>scene_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activate a scene, making its entities visible to systems. </p>
<p>Sets the scene to MAIN or ACTIVE state (implementation-dependent). Entities with this scene's <a class="el" href="structScene.html" title="Component that associates an entity with a specific scene.">Scene</a> component will be processed by systems.</p>
<p>If another scene is currently MAIN and this scene is set to MAIN, the previous MAIN scene typically becomes ACTIVE or DISABLED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scene_name</td><td>Name of the scene to activate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="structScene.html" title="Component that associates an entity with a specific scene.">Scene</a> must be registered with <a class="el" href="classRegistry.html#adfbcd0eed55c7f0d795443ef0f34c855" title="Register a scene with the given name and initial state.">add_scene()</a> first </dd>
<dd>
Entities in the scene become visible to system iteration </dd>
<dd>
Only one scene should be MAIN at a time</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>If scene_name was not registered</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="comment">// Switch from menu to gameplay</span></div>
<div class="line">registry.remove_current_scene(<span class="stringliteral">&quot;menu&quot;</span>);</div>
<div class="line">registry.set_current_scene(<span class="stringliteral">&quot;gameplay&quot;</span>);</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Show pause menu over gameplay</span></div>
<div class="line"><span class="comment">// (both scenes active - systems process both)</span></div>
<div class="line">registry.set_current_scene(<span class="stringliteral">&quot;gameplay&quot;</span>);  <span class="comment">// MAIN</span></div>
<div class="line">registry.set_current_scene(<span class="stringliteral">&quot;pause_menu&quot;</span>);  <span class="comment">// ACTIVE overlay</span></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">void</span> start_level(<a class="code hl_class" href="classRegistry.html">Registry</a>&amp; r, <span class="keyword">const</span> std::string&amp; level) {</div>
<div class="line">  <span class="comment">// Hide menu</span></div>
<div class="line">  r.<a class="code hl_function" href="classRegistry.html#a936cd3eebe707ee32e2aac62eb079404">remove_current_scene</a>(<span class="stringliteral">&quot;menu&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Show gameplay and HUD</span></div>
<div class="line">  r.<a class="code hl_function" href="classRegistry.html#ad1c9d136cf9da966ef0977d3c698a963">set_current_scene</a>(level);  <span class="comment">// Gameplay scene</span></div>
<div class="line">  r.<a class="code hl_function" href="classRegistry.html#ad1c9d136cf9da966ef0977d3c698a963">set_current_scene</a>(<span class="stringliteral">&quot;hud&quot;</span>);  <span class="comment">// HUD overlay</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRegistry.html#adfbcd0eed55c7f0d795443ef0f34c855" title="Register a scene with the given name and initial state.">add_scene()</a> to register scenes </dd>
<dd>
<a class="el" href="classRegistry.html#a936cd3eebe707ee32e2aac62eb079404" title="Deactivate a specific scene.">remove_current_scene()</a> to deactivate </dd>
<dd>
<a class="el" href="classRegistry.html#a0b9eb2723831a87cb5602c43e2b05b0a" title="Get list of currently active scene names.">get_current_scene()</a> to query active scenes </dd></dl>

</div>
</div>
<a id="a9fbf6f291355b03ad61105e4ba682299" name="a9fbf6f291355b03ad61105e4ba682299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fbf6f291355b03ad61105e4ba682299">&#9670;&#160;</a></span>set_main_scene()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Registry::set_main_scene </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>scene_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a scene as the MAIN scene. </p>
<p>Sets the scene to MAIN state (highest priority). Entities in this scene will always be processed by systems.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scene_name</td><td>Name of the scene to set as MAIN</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Multiple scenes can be MAIN simultaneously </dd>
<dd>
<a class="el" href="structScene.html" title="Component that associates an entity with a specific scene.">Scene</a> must be registered with <a class="el" href="classRegistry.html#adfbcd0eed55c7f0d795443ef0f34c855" title="Register a scene with the given name and initial state.">add_scene()</a> first</dd></dl>
<div class="fragment"><div class="line">registry.set_main_scene(<span class="stringliteral">&quot;gameplay&quot;</span>);</div>
<div class="line">registry.set_current_scene(<span class="stringliteral">&quot;hud&quot;</span>);  <span class="comment">// ACTIVE overlay over MAIN gameplay</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRegistry.html#ad1c9d136cf9da966ef0977d3c698a963" title="Activate a scene, making its entities visible to systems.">set_current_scene()</a> to set scene as <a class="el" href="Scenes_8hpp.html#ab0d98f61608665befb0dc9afa0419e19a18ff74f43da410c5529f7d6fca84f115" title="Scene is active, entities are processed.">ACTIVE</a> </dd>
<dd>
<a class="el" href="classRegistry.html#adfbcd0eed55c7f0d795443ef0f34c855" title="Register a scene with the given name and initial state.">add_scene()</a> to register scenes </dd></dl>

</div>
</div>
<a id="a35e8c1f487a94aaf2752678d814a942a" name="a35e8c1f487a94aaf2752678d814a942a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e8c1f487a94aaf2752678d814a942a">&#9670;&#160;</a></span>setup_scene_systems()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Registry::setup_scene_systems </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setup automatic scene management systems. </p>
<p>Registers systems that automatically handle scene transitions, entity filtering, and scene state updates. This is optional but recommended for automatic scene behavior.</p>
<dl class="section note"><dt>Note</dt><dd>Call after <a class="el" href="classRegistry.html#a676be837cc2defb394f38b32d664fd30" title="Initialize the scene management system.">init_scene_management()</a> </dd>
<dd>
Adds systems to the <a class="el" href="classRegistry.html" title="The Registry class is the core of the ECS (Entity-Component-System) architecture.">Registry</a>'s system pipeline</dd></dl>
<div class="fragment"><div class="line">registry.init_scene_management();</div>
<div class="line">registry.setup_scene_systems();  <span class="comment">// Enable automatic scene handling</span></div>
<div class="line">registry.add_scene(<span class="stringliteral">&quot;gameplay&quot;</span>, <a class="code hl_enumvalue" href="Scenes_8hpp.html#ab0d98f61608665befb0dc9afa0419e19a18ff74f43da410c5529f7d6fca84f115">SceneState::ACTIVE</a>);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRegistry.html#a676be837cc2defb394f38b32d664fd30" title="Initialize the scene management system.">init_scene_management()</a> must be called first </dd></dl>

</div>
</div>
<a id="a2e982e5c9b7207dce933e2210b4cce4b" name="a2e982e5c9b7207dce933e2210b4cce4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e982e5c9b7207dce933e2210b4cce4b">&#9670;&#160;</a></span>spawn_entity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceEcs.html#a17fcea5750c1db2eea6f26c520f9235b">Ecs::Entity</a> Registry::spawn_entity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spawns a new entity. </p>
<p>Allocates a unique entity ID by either:</p><ul>
<li>Recycling a previously deleted entity ID from _dead_entities queue</li>
<li>Incrementing _max counter to create a new ID</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Unique entity identifier</dd></dl>
<p>Entities are lightweight indices. This function only allocates the ID; components must be added separately via <a class="el" href="classRegistry.html#a9990d86dfe7f90e314f8e93773b307d4" title="Adds a component to an entity by moving.">add_component()</a> or <a class="el" href="classRegistry.html#aedaff3e905a52a1945250cd16ffbb5fb" title="Constructs a component in-place on an entity.">emplace_component()</a>.</p>
<p>The recycling mechanism ensures ID space stays compact:</p><ul>
<li>When entities are killed, their IDs go into _dead_entities queue</li>
<li><a class="el" href="classRegistry.html#a2e982e5c9b7207dce933e2210b4cce4b" title="Spawns a new entity.">spawn_entity()</a> prefers recycled IDs over creating new ones</li>
<li>This prevents unbounded ID growth in long-running games</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Entity 0 is valid - entities start from 0 </dd>
<dd>
No maximum entity limit (bounded by size_t max) </dd>
<dd>
Thread-unsafe - single-threaded use only</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_class" href="classRegistry.html">Registry</a> registry;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> player = registry.<a class="code hl_function" href="classRegistry.html#a2e982e5c9b7207dce933e2210b4cce4b">spawn_entity</a>();    <span class="comment">// ID: 0</span></div>
<div class="line"><span class="keyword">auto</span> enemy1 = registry.<a class="code hl_function" href="classRegistry.html#a2e982e5c9b7207dce933e2210b4cce4b">spawn_entity</a>();    <span class="comment">// ID: 1</span></div>
<div class="line"><span class="keyword">auto</span> enemy2 = registry.<a class="code hl_function" href="classRegistry.html#a2e982e5c9b7207dce933e2210b4cce4b">spawn_entity</a>();    <span class="comment">// ID: 2</span></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">auto</span> bullet = registry.<a class="code hl_function" href="classRegistry.html#a2e982e5c9b7207dce933e2210b4cce4b">spawn_entity</a>();</div>
<div class="line">registry.<a class="code hl_function" href="classRegistry.html#a9990d86dfe7f90e314f8e93773b307d4">add_component</a>(bullet, <a class="code hl_struct" href="structPosition.html">Position</a>{100, 50});</div>
<div class="line">registry.<a class="code hl_function" href="classRegistry.html#a9990d86dfe7f90e314f8e93773b307d4">add_component</a>(bullet, Velocity{10, 0});</div>
<div class="line">registry.<a class="code hl_function" href="classRegistry.html#a9990d86dfe7f90e314f8e93773b307d4">add_component</a>(bullet, <a class="code hl_struct" href="structSprite.html">Sprite</a>{<span class="stringliteral">&quot;bullet.png&quot;</span>});</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">auto</span> e1 = registry.<a class="code hl_function" href="classRegistry.html#a2e982e5c9b7207dce933e2210b4cce4b">spawn_entity</a>();  <span class="comment">// 0</span></div>
<div class="line"><span class="keyword">auto</span> e2 = registry.<a class="code hl_function" href="classRegistry.html#a2e982e5c9b7207dce933e2210b4cce4b">spawn_entity</a>();  <span class="comment">// 1</span></div>
<div class="line"><span class="keyword">auto</span> e3 = registry.<a class="code hl_function" href="classRegistry.html#a2e982e5c9b7207dce933e2210b4cce4b">spawn_entity</a>();  <span class="comment">// 2</span></div>
<div class="line"> </div>
<div class="line">registry.<a class="code hl_function" href="classRegistry.html#a9f8e76e4f67a4e33dd7273d065d6be7a">kill_entity</a>(e2);           <span class="comment">// Mark 1 for deletion</span></div>
<div class="line">registry.<a class="code hl_function" href="classRegistry.html#a2cf00a9ea3b232b551de02598cbc7756">process_entity_deletions</a>(); <span class="comment">// Delete 1, add to queue</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> e4 = registry.<a class="code hl_function" href="classRegistry.html#a2e982e5c9b7207dce933e2210b4cce4b">spawn_entity</a>();  <span class="comment">// 1 (recycled!)</span></div>
<div class="line"><span class="keyword">auto</span> e5 = registry.<a class="code hl_function" href="classRegistry.html#a2e982e5c9b7207dce933e2210b4cce4b">spawn_entity</a>();  <span class="comment">// 3 (new)</span></div>
<div class="ttc" id="aclassRegistry_html_a2cf00a9ea3b232b551de02598cbc7756"><div class="ttname"><a href="classRegistry.html#a2cf00a9ea3b232b551de02598cbc7756">Registry::process_entity_deletions</a></div><div class="ttdeci">void process_entity_deletions()</div><div class="ttdoc">Deletes all entities marked for killing.</div><div class="ttdef"><b>Definition</b> Registry.cpp:41</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRegistry.html#a9f8e76e4f67a4e33dd7273d065d6be7a" title="Marks an entity for deletion.">kill_entity()</a> to destroy entities </dd>
<dd>
<a class="el" href="classRegistry.html#a2cf00a9ea3b232b551de02598cbc7756" title="Deletes all entities marked for killing.">process_entity_deletions()</a> to recycle IDs </dd></dl>

</div>
</div>
<a id="ae99ff1a3c4f750cba3bb80534f4295c4" name="ae99ff1a3c4f750cba3bb80534f4295c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae99ff1a3c4f750cba3bb80534f4295c4">&#9670;&#160;</a></span>update_bindings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Registry::update_bindings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEventManager.html">EventManager</a> &amp;&#160;</td>
          <td class="paramname"><em>em</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates all registered dynamic bindings. </p>
<p>Synchronizes component fields that are bound to other component values. For each binding, copies the source value to the target field.</p>
<p>Called automatically at the start of <a class="el" href="classRegistry.html#ae484ce9b1fdb58e76997409a74227701" title="Registers a system function to run every frame.">run_systems()</a>. Processes _bindings vector, executing each binding's updater function to copy values.</p>
<p>Bindings are created via <a class="el" href="classRegistry.html#a529bdf9002188825f7b03f33b2991624" title="Registers a dynamic binding between component fields.">register_binding()</a> during component construction from JSON with # hook syntax.</p>
<dl class="section note"><dt>Note</dt><dd>Automatically called by <a class="el" href="classRegistry.html#ae484ce9b1fdb58e76997409a74227701" title="Registers a system function to run every frame.">run_systems()</a> - manual call rarely needed </dd>
<dd>
Order of binding updates matches registration order </dd>
<dd>
Failed bindings are silently ignored (no error thrown)</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Bindings updated automatically</span></div>
<div class="line"><span class="keywordflow">while</span> (running) {</div>
<div class="line">  <span class="comment">// Leader moves</span></div>
<div class="line">  leader_pos.x += 10;</div>
<div class="line"> </div>
<div class="line">  registry.run_systems();</div>
<div class="line">  <span class="comment">// update_bindings() called here</span></div>
<div class="line">  <span class="comment">// Follower.target_pos now equals Leader.pos</span></div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Force binding sync mid-frame (unusual)</span></div>
<div class="line">leader_position.x = 500;</div>
<div class="line">registry.update_bindings();  <span class="comment">// Sync immediately</span></div>
<div class="line"><span class="comment">// Follower now tracks new position</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRegistry.html#a529bdf9002188825f7b03f33b2991624" title="Registers a dynamic binding between component fields.">register_binding()</a> to create bindings </dd>
<dd>
<a class="el" href="classRegistry.html#ae484ce9b1fdb58e76997409a74227701" title="Registers a system function to run every frame.">run_systems()</a> which calls this automatically </dd>
<dd>
<a class="el" href="classRegistry.html#ab44989c0361996ad2c4aefbf4636b664" title="Removes all registered bindings.">clear_bindings()</a> to remove all bindings </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/ecs/<a class="el" href="Registry_8hpp_source.html">Registry.hpp</a></li>
<li>src/<a class="el" href="Registry_8cpp.html">Registry.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
