================================================================================
COMPARATIVE STUDY: TCP vs UDP FOR A VIDEO GAME ENGINE
R-Type Project - EPITECH 2025
================================================================================

TABLE OF CONTENTS
================================================================================

1. R-Type Project Analysis
2. Technical Comparison: TCP vs UDP
3. Comparative Analysis for R-Type Game
4. Use Cases Where TCP Would Be Problematic
5. RTCP Protocol Architecture
6. Comparison with other games Protocols
7. Performance Measurements
8. Recommendations and Best Practices
9. Test Scenarios
10. Conclusion

================================================================================
1. R-TYPE PROJECT ANALYSIS
================================================================================

The R-Type project is a real-time multiplayer shoot 'em up (shmup) game 
supporting up to 4 simultaneous players in cooperative mode. The game requires 
fast synchronization of entity positions, gameplay events, and player actions.

================================================================================
2. TECHNICAL COMPARISON: TCP vs UDP
================================================================================

2.1 FUNDAMENTAL CHARACTERISTICS
--------------------------------------------------------------------------------

CRITERION               | TCP                           | UDP
------------------------|-------------------------------|---------------------------
Connection type         | Connection-oriented           | Connectionless
Reliability             | Guaranteed delivery           | No guarantee
Flow control            | Yes (windowing, congestion)   | No
Overhead                | 20-60 bytes + retrans.        | 8 bytes fixed
Latency                 | Variable (retrans, buffer)    | Predictable and minimal
Packet ordering         | Guaranteed (auto sequencing)  | Not guaranteed
Error detection         | Checksum + retransmission     | Checksum only
Congestion control      | Yes (slow start, etc.)        | No

2.2 PERFORMANCE IN GAMING ENVIRONMENT
--------------------------------------------------------------------------------

LATENCY AND RESPONSIVENESS:

TCP:
- Typical latency: 50-200ms (including retransmissions)
- Head-of-line blocking: one lost packet blocks all subsequent ones
- Mandatory buffering to guarantee ordering
- Connection establishment time: ~1.5 RTT

UDP:
- Typical latency: 10-50ms (direct path)
- No blocking: each packet is independent
- No automatic buffering
- Immediate sending without prior handshake

THROUGHPUT AND OVERHEAD:

For a 100-byte data packet:

TCP:
    IP Header:      20 bytes
    TCP Header:     20-60 bytes (with options)
    Data:           100 bytes
    Total:          140-180 bytes
    Overhead:       40-80% (not counting retransmissions)

UDP:
    IP Header:      20 bytes
    UDP Header:     8 bytes
    Data:           100 bytes
    Total:          128 bytes
    Overhead:       28%

================================================================================
3. COMPARATIVE ANALYSIS FOR R-TYPE GAME
================================================================================

3.1 GAME-SPECIFIC REQUIREMENTS
--------------------------------------------------------------------------------

UPDATE FREQUENCY:

An action game like R-Type requires:
- Refresh rate: 30-60 Hz (every 16-33ms)
- Position updates: Every frame
- Input reaction: < 50ms for smooth experience
- Synchronization: Frequent and redundant game states

EXCHANGED DATA TYPES:

According to the RTCP specification, the game exchanges:

1. Entity components (srv_sendcomp):
   - Position, velocity, health
   - Frequency: High (every game tick)
   - Criticality: Medium (next state corrects previous state)

2. Game events (srv_sendevent, cli_sendevent):
   - Weapon fire, player deaths, enemy spawns
   - Frequency: Variable
   - Criticality: Variable (some events are critical)

3. Connection packets (connectionless packets):
   - Discovery, authentication, status
   - Frequency: Low
   - Criticality: High

3.2 USAGE SCENARIOS
--------------------------------------------------------------------------------

SCENARIO 1: POSITION UPDATE

With TCP:
    Frame 1: Send position (100, 200)
    Frame 2: Send position (110, 205) 
    [Frame 1 packet lost]
    Frame 3: Send position (120, 210)
    [TCP retransmits Frame 1]
    Frame 4: Receives Frame 1 (100, 200) - OBSOLETE DATA
            Receives Frame 2 (110, 205) - OBSOLETE DATA
            Receives Frame 3 (120, 210)

Result: INCREASED LATENCY and STALE DATA received.

With UDP:
    Frame 1: Send position (100, 200)
    Frame 2: Send position (110, 205)
    [Frame 1 packet lost - ignored]
    Frame 3: Send position (120, 210)
    Frame 4: Receives Frame 2 (110, 205)
            Receives Frame 3 (120, 210)

Result: CURRENT DATA received without delay.

SCENARIO 2: NETWORK CONGESTION

With TCP:
    1. Detects congestion
    2. Reduces sending window (slow start)
    3. Gradually increases throughput
    4. IMPACT: Global game slowdown for several seconds

With UDP:
    1. Continues sending at same rate
    2. Lost packets are simply ignored
    3. Game remains smooth with minor visual glitches
    4. IMPACT: Micro-interruptions rather than generalized slowdown

================================================================================
4. JUSTIFICATION OF UDP CHOICE FOR R-TYPE
================================================================================

4.1 DECISIVE ADVANTAGES OF UDP
--------------------------------------------------------------------------------

A. PRESERVING FLUIDITY

In a real-time action game:
- PRIORITY: Display current state > Display all historical states
- PRINCIPLE: "Better to skip than to lag"
- Players prefer slight visual discontinuity to constant lag

Concrete example: An enemy ship jumping from (100, 50) to (120, 50) is 
preferable to a game slowing down to wait for missing packets.

B. PREDICTABLE LATENCY

    UDP: Latency = Network transmission time
    TCP: Latency = Transmission time + Retransmission delay + Buffering

For competitive gaming, PREDICTABILITY is as important as absolute latency. 
Players can adapt to constant 50ms latency, but not to latency varying 
between 20ms and 200ms.

C. APPLICATION CONTROL

The RTCP protocol implements:
- Custom sequencing: sequence_number in connected packets
- Controlled fragmentation: end_of_content system for large messages
- Prioritization: Ability to send critical events first
- Selective redundancy: Manual resending of important data

Example of intelligent redundancy in code:

    // Send current position every frame
    sendComponent(entity_id, "Position", current_pos);

    // For critical event, send 3 times
    for (int i = 0; i < 3; i++) {
        sendEvent("PlayerDeath", death_data);
    }

D. BANDWIDTH OPTIMIZATION

With 4 players at 60 Hz:

TCP (hypothetical):
    Data per frame:         4 players × 50 bytes = 200 bytes
    TCP overhead:           200 × 0.4 = 80 bytes
    Retransmissions (5%):   200 × 0.05 = 10 bytes
    Total per frame:        290 bytes
    Total per second:       290 × 60 = 17,400 bytes/s ≈ 139 kbit/s

UDP (current implementation):
    Data per frame:         200 bytes
    UDP overhead:           200 × 0.28 = 56 bytes
    Total per frame:        256 bytes
    Total per second:       256 × 60 = 15,360 bytes/s ≈ 123 kbit/s

SAVINGS: ~12% bandwidth + no unpredictable spikes due to retransmissions.

4.2 MANAGING UDP DISADVANTAGES
--------------------------------------------------------------------------------

PROBLEM 1: PACKET LOSS

RTCP Solution:
- Redundant state: Every frame sends complete state (position, velocity)
- Critical events: Event system with possible application-level resending
- Challenge-response: For connection only (where reliability is needed)

Code example:

    // Example: Confirmation system for critical events
    if (event.critical) {
        sendEventWithConfirmation(event);
    } else {
        sendEvent(event);  // Fire and forget
    }

PROBLEM 2: OUT-OF-ORDER PACKETS

RTCP Solution:

    // In connected packet header
    struct ConnectedPacketHeader {
        uint32_t magic_sequence;
        uint32_t sequence_number;  // Out-of-order detection
        uint32_t acknowledge;       // Reserved for future use
        uint8_t end_of_content;
    };

    // Reception side
    if (packet.sequence_number < last_sequence) {
        discard_packet();  // Late packet, ignored
    }

PROBLEM 3: NO FLOW CONTROL

RTCP Solution:
- Size limit: MAX_PACKET_SIZE = 2048 bytes
- Fragmentation: Fragment system for large messages
- Application rate limiting: Control number of sends per frame

================================================================================
5. USE CASES WHERE TCP WOULD BE PROBLEMATIC
================================================================================

5.1 HEAD-OF-LINE BLOCKING
--------------------------------------------------------------------------------

Scenario:
- Frame 100: Send position A
- Frame 101: Send position B (lost)
- Frame 102: Send position C
- Frame 103: Send position D

With TCP:
    Client waits indefinitely for position B
    Positions C and D are buffered
    When B finally arrives, client receives B, C, D all at once
    Result: Ship teleportation or freeze then catch-up

With UDP:
    Client receives A, C, D
    B is lost but doesn't affect C and D
    Result: Slight jump from B to C, but game continues smoothly

5.2 RETRANSMISSION OF STALE DATA
--------------------------------------------------------------------------------

In a 60 FPS game, each frame lasts ~16ms. If a packet is lost:

TCP:
- Typical RTT (Round-Trip Time): 50ms
- Packet is retransmitted after ~50ms
- Meanwhile, 3 NEW FRAMES have been generated
- Retransmitted data is OBSOLETE

UDP:
- Packet is lost
- Next packet (16ms later) contains current state
- No stale data received

5.3 CONGESTION AND THROTTLING
--------------------------------------------------------------------------------

Scenario: Temporary network congestion (5%)

TCP:
    1. Detects 5% loss
    2. Enters slow start
    3. Reduces throughput by 50%
    4. Game slows down or freezes
    5. Gradually recovers over 2-3 seconds
    6. User impact: Game unplayable for 3 seconds

UDP:
    1. 5% of packets lost
    2. 95% of updates arrive normally
    3. Slight visual stutter
    4. User impact: Acceptable and brief

================================================================================
6. RTCP PROTOCOL ARCHITECTURE
================================================================================

6.1 UDP-ORIENTED DESIGN
--------------------------------------------------------------------------------

The RTCP protocol was designed from the start to leverage UDP's strengths:

A. STATELESS PACKETS (CONNECTIONLESS)

    GETINFO       → Server discovery
    GETSTATUS     → Current state
    GETCHALLENGE  → Authentication
    CONNECT       → Establishment

Each packet is INDEPENDENT and can be lost without affecting others. 
Request repetition is handled by the application (client can resend GETINFO 
until receiving a response).

B. STATEFUL PACKETS (CONNECTED)

Structure:
    struct ConnectedPacket {
        uint32_t magic_sequence;     // Validation
        uint32_t sequence_number;    // Logical ordering
        uint32_t acknowledge;        // Future: Selective ACKs
        uint8_t end_of_content;      // Fragmentation
        // Payload: srv_sendcomp, srv_sendevent, cli_sendevent
    };

Key design:
- sequence_number: Allows detection of loss and disorder
- end_of_content: Manual fragmentation (no TCP reassembly)
- No retransmission window: Application decides what to resend

C. ENTITY-COMPONENT SYSTEM

Format:
    srv_sendcomp: [entity_id:64] [component_id:string] [data:variable]

Advantages for UDP:
- Partial update: Only modified components are sent
- Idempotence: Receiving same component twice is not a problem
- Delta encoding: Easy to send only changes

Example:
    // Frame N
    sendComponent(enemy_42, "Position", {x: 100, y: 200});

    // Frame N+1 (position change)
    sendComponent(enemy_42, "Position", {x: 105, y: 200});

    // Frame N+2 (velocity change)
    sendComponent(enemy_42, "Velocity", {dx: 5, dy: 0});

If a packet is lost, the next update corrects the state.

6.2 SELECTIVE RELIABILITY MECHANISMS
--------------------------------------------------------------------------------

The RTCP protocol implements reliability ONLY WHERE NECESSARY:

CONNECTION (CRITICAL):

    Client                          Server
      |                                |
      |------ GETCHALLENGE ----------->|
      |                                |
      |<----- CHALLENGERESPONSE -------|
      |      (challenge: 0x12345678)   |
      |                                |
      |------ CONNECT --------------->|
      |      (challenge: 0x12345678)   |
      |                                |
      |<----- CONNECTRESPONSE ---------|

If a packet is lost, the CLIENT RETRIES. This is acceptable because:
- Low frequency (once per session)
- Limited impact (connection delay)
- Simple to implement (timeout + retry)

GAME EVENTS (VARIABLE):

    // Non-critical event (weapon fire)
    sendEvent("FireWeapon", weapon_data);
    // Lost? No problem, next shot will be sent

    // Critical event (player death)
    for (int i = 0; i < 3; i++) {
        sendEvent("PlayerDeath", death_data);
    }
    // Sent 3 times to guarantee reception

COMPONENTS (NON-CRITICAL):

    // Sent every frame
    sendComponent(player_id, "Position", position);
    // Lost? Next frame will send new position

================================================================================
7. COMPARISON WITH OTHER GAME PROTOCOLS
================================================================================

7.1 EXISTING PROPRIETARY PROTOCOLS
--------------------------------------------------------------------------------

GAME/ENGINE         | PROTOCOL              | TRANSPORT    | APPROACH
--------------------|------------------------|--------------|---------------------
Quake 3             | Quake 3 Protocol       | UDP          | Delta compression
Source Engine       | Source TV Protocol     | UDP          | Delta encoding
Unreal Engine       | UE Networking          | UDP          | Property replication
Fortnite            | Replication Graph      | UDP + custom | Prioritization
Minecraft (Java)    | Minecraft Protocol     | TCP          | Compression, chunks
World of Warcraft   | WoW Protocol           | TCP          | Opcodes, encryption

OBSERVATION: Fast-action games (FPS, shmup) ALL use UDP, while MMOs and 
turn-based games may use TCP.

7.2 RTCP VS QUAKE 3 PROTOCOL
--------------------------------------------------------------------------------

SIMILARITIES:
- UDP transport
- Manual sequencing
- Possible delta compression
- Separate events and states

DIFFERENCES:

ASPECT              | RTCP                          | QUAKE 3
--------------------|-------------------------------|---------------------------
Architecture        | ECS (Entity-Component-System) | Monolithic game state
Reliability         | Selective (application-level) | Channel-based
Compression         | None (current spec)           | Huffman encoding
Prediction          | Not specified                 | Client-side prediction

7.3 LESSONS FROM EXISTING PROTOCOLS
--------------------------------------------------------------------------------

A. CLIENT-SIDE PREDICTION

Quake 3 introduces the concept of client-side prediction:
    1. Client sends input to server
    2. Client immediately predicts result
    3. Server returns authoritative state
    4. Client corrects if necessary (reconciliation)

Application to RTCP:

    // Client predicts locally
    local_position = predict(input, current_state);
    sendEvent("PlayerMove", input);

    // Server returns truth
    onReceiveComponent("Position", server_position) {
        reconcile(local_position, server_position);
    }

B. RELEVANCE ZONES (INTEREST MANAGEMENT)

Large games like Fortnite only send RELEVANT entities:

    // For each player
    for (entity in world) {
        if (distance(player, entity) < RELEVANCE_RADIUS) {
            sendComponent(entity, "Position", position);
        }
    }

Application to RTCP: The component system easily allows this optimization.

================================================================================
8. PERFORMANCE MEASUREMENTS
================================================================================

8.1 THEORETICAL BENCHMARKS
--------------------------------------------------------------------------------

For an R-Type session with 4 players, 60 FPS:

DATA PER FRAME:
- 4 players × Position (16 bytes) = 64 bytes
- 4 players × Velocity (16 bytes) = 64 bytes
- 10 enemies × Position = 160 bytes
- 5 average events = 100 bytes
- TOTAL DATA: ~388 bytes/frame

WITH TCP:
    Network overhead:       388 × 0.4 = 155 bytes
    Retransmissions (3%):   388 × 0.03 = 12 bytes
    Total per frame:        555 bytes
    Bandwidth:              555 × 60 = 33,300 bytes/s ≈ 266 kbit/s

    Typical latency:        50-150ms (variable)
    Jitter:                 ±50ms (retransmissions)

WITH UDP (RTCP):
    Network overhead:       388 × 0.28 = 109 bytes
    Total per frame:        497 bytes
    Bandwidth:              497 × 60 = 29,820 bytes/s ≈ 239 kbit/s

    Typical latency:        20-40ms (stable)
    Jitter:                 ±5ms

SAVINGS:
- Bandwidth: ~10% reduction
- Latency: 50-60% reduction
- Stability: Significantly superior

8.2 IMPACT ON PLAYER EXPERIENCE
--------------------------------------------------------------------------------

EXAMPLE: REACTION TIME

A player sees an enemy and fires:

With TCP (100ms latency):
    T=0ms:    Player presses "Fire"
    T=100ms:  Server receives input
    T=100ms:  Server processes and sends result
    T=200ms:  Player sees result
    → 200ms total delay

With UDP (30ms latency):
    T=0ms:    Player presses "Fire"
    T=30ms:   Server receives input
    T=30ms:   Server processes and sends result
    T=60ms:   Player sees result
    → 60ms total delay

IMPACT: In a fast-action game, 140ms difference can determine who wins or 
loses a confrontation.

EXAMPLE: PACKET LOSS (5%)

With TCP:
- 1 packet lost out of 20
- Retransmission time: ~100ms (1 RTT)
- IMPACT: 100ms freeze every second
- Experience: UNPLAYABLE

With UDP:
- 1 packet lost out of 20
- Next update in 16ms
- IMPACT: Micro visual glitch
- Experience: ACCEPTABLE

================================================================================
9. RECOMMENDATIONS AND BEST PRACTICES
================================================================================

9.1 RECOMMENDED OPTIMIZATIONS FOR RTCP
--------------------------------------------------------------------------------

A. DATA COMPRESSION

    // Before: Position in float64 (8 bytes × 2 = 16 bytes)
    struct Position {
        double x, y;
    };

    // After: Position in int16 (2 bytes × 2 = 4 bytes)
    // Resolution: 0.1 pixel, range: -3276.8 to 3276.7
    struct CompressedPosition {
        int16_t x_scaled;  // x * 10
        int16_t y_scaled;  // y * 10
    };

    // Savings: 75% reduction

B. DELTA ENCODING

    // Instead of sending complete position:
    sendComponent("Position", {x: 1523, y: 742});

    // Send only the change:
    sendComponent("PositionDelta", {dx: +5, dy: -2});

    // Savings: Often 50-70% on positions

C. PACKET PRIORITIZATION

    // High: Critical events
    sendPriority(HIGH, "PlayerDeath", data);

    // Medium: Player components
    sendPriority(MEDIUM, player_id, "Position", pos);

    // Low: Distant enemy components
    sendPriority(LOW, enemy_id, "Position", pos);

9.2 ROBUST LOSS MANAGEMENT
--------------------------------------------------------------------------------

A. HEARTBEAT

    // Send heartbeat every 5 seconds
    every 5 seconds:
        sendEvent("Heartbeat", {timestamp: now()});

    // Detect disconnections
    if (time_since_last_heartbeat > 10 seconds):
        disconnect_client();

B. PERIODIC FULL STATE

    // Every 10 frames, send full state
    if (frame_count % 10 == 0):
        sendFullSnapshot(all_entities);
    else:
        sendDeltaUpdate(changed_entities);

C. CONFIRMATION FOR CRITICAL EVENTS

    // Client sends
    sendEventWithId(event_id, "StartGame", data);

    // Server confirms
    onReceive("StartGame", event_id) {
        sendConfirmation(event_id);
    }

    // Client retries if no confirmation
    if (no_confirmation_after(1_second)) {
        resend(event_id);
    }

================================================================================
10. TEST SCENARIOS
================================================================================

10.1 PACKET LOSS TEST
--------------------------------------------------------------------------------

CONFIGURATION:
- 4 connected players
- Simulated packet loss: 0%, 1%, 5%, 10%, 20%
- Measurements: Fluidity, perceived latency, synchronization

EXPECTED RESULTS WITH UDP:

LOSS    | EXPERIENCE           | SYNCHRONIZATION
--------|----------------------|------------------
0-1%    | Perfect              | Perfect
5%      | Slight stuttering    | Good (99%+)
10%     | Visible stuttering   | Acceptable (95%+)
20%     | Degraded but playable| Partial (80%+)

EXPECTED RESULTS WITH TCP:

LOSS    | EXPERIENCE           | SYNCHRONIZATION
--------|----------------------|---------------------------
0-1%    | Good                 | Perfect
5%      | Frequent freezes     | Perfect but slow
10%     | Nearly unplayable    | Perfect but very slow
20%     | Unplayable           | Perfect but unusable

10.2 NETWORK LATENCY TEST
--------------------------------------------------------------------------------

CONFIGURATION:
- Artificial latency: 20ms, 50ms, 100ms, 200ms
- Measurements: Input lag, reaction time

UDP:
    Network latency:  20ms   50ms   100ms  200ms
    Input lag:        40ms   100ms  200ms  400ms
    Perception:       Perfect Good   OK     Poor

TCP:
    Network latency:  20ms   50ms   100ms  200ms
    Input lag:        60ms   150ms  300ms  600ms
    Perception:       Good   OK     Bad    Unplayable

================================================================================
11. CONCLUSION
================================================================================

11.1 SUMMARY OF UDP ADVANTAGES FOR R-TYPE
--------------------------------------------------------------------------------

CRITERION             | IMPORTANCE | UDP ADVANTAGE
----------------------|------------|----------------------------------
Latency               | Critical   | +++++ (50-70% lower)
Fluidity              | Critical   | +++++ (no blocking)
Bandwidth             | Medium     | +++ (10-15% savings)
Predictability        | High       | +++++ (stable behavior)
Application control   | High       | +++++ (total flexibility)
Complexity            | Medium     | +++ (well-defined spec)

11.2 JUSTIFICATION OF THE CHOICE
--------------------------------------------------------------------------------

The choice of UDP for R-Type is justified by FIVE MAJOR REASONS:

1. GAME NATURE
   R-Type is a real-time shoot 'em up requiring MAXIMUM RESPONSIVENESS. Every 
   millisecond counts for dodging enemy projectiles or synchronizing shots. 
   TCP's delivery guarantee is COUNTERPRODUCTIVE as it prioritizes completeness 
   over data freshness.

2. LOSS TOLERANCE
   In a game where state is updated 60 times per second, LOSING ONE PACKET 
   OUT OF 20 IS NEGLIGIBLE. The next packet (arriving 16ms later) already 
   contains the updated state. TCP, on the other hand, would block the game 
   to retransmit already obsolete data.

3. ECS ARCHITECTURE
   The entity-component system of the RTCP protocol is NATURALLY SUITED TO UDP:
   - Components are independent
   - Updates are idempotent
   - Partial synchronization is acceptable

4. GRANULAR CONTROL
   UDP allows implementing EXACTLY THE NECESSARY RELIABILITY for each data type:
   - Entity positions: No reliability (redundant data)
   - Critical events: Application reliability (multiple sends)
   - Initial connection: Reliability by retry (acceptable for rare event)

   With TCP, we would have ALL RELIABILITY FOR EVERYTHING, including data 
   that doesn't need it.

5. SCALABILITY
   For a server managing 4 sessions of 4 players (16 total clients):
   - UDP: Constant bandwidth, predictable latency
   - TCP: Cascading retransmissions, cross-session congestion, unpredictable 
     behavior

11.3 CASES WHERE TCP WOULD HAVE BEEN PREFERABLE
--------------------------------------------------------------------------------

TCP would be justified if R-Type had:
- A text chat system (message ordering critical)
- A transaction system (item purchases, final scores)
- Turn-based mode (no real-time constraint)
- File transfer (custom maps, replays)

For these features, one could consider a HYBRID ARCHITECTURE:
    UDP: Real-time gameplay
    TCP: Chat, transactions, downloads

11.4 CHOICE VALIDATION
--------------------------------------------------------------------------------

The RTCP protocol demonstrates DEEP UNDERSTANDING of network trade-offs for 
real-time games:

✓ Manual sequencing rather than automatic TCP
✓ Controlled fragmentation rather than automatic MSS/MTU
✓ Selective reliability rather than universal reliability
✓ Minimal overhead (28%) vs TCP (40-80%)
✓ Optimal latency for competitive action game

The choice of UDP is not only JUSTIFIED, it is OPTIMAL for this use case.

11.5 FINAL SUMMARY TABLE
--------------------------------------------------------------------------------

ASPECT                  | TCP                    | UDP (RTCP)
------------------------|------------------------|---------------------------
Average latency         | 100-200ms              | 20-40ms
Latency with 5% loss    | 200-500ms (freezes)    | 20-40ms (stable)
Bandwidth               | 266 kbit/s             | 239 kbit/s
Overhead                | 40-80%                 | 28%
Packet loss handling    | Auto retransmission    | Ignored or manual retry
Head-of-line blocking   | YES (problematic)      | NO
Application control     | Limited                | Total
Reliability             | Always                 | Selective
Implementation complexity| Simple (OS-provided)  | Medium (custom protocol)
User experience         | Poor (freezes)         | Excellent (smooth)
Suited for R-Type       | NO                     | YES

11.6 FINAL RECOMMENDATIONS
--------------------------------------------------------------------------------

FOR THE R-TYPE PROJECT:

1. MAINTAIN UDP CHOICE
   The RTCP protocol is perfectly suited to the game's needs. Do not consider 
   TCP as an alternative.

2. IMPLEMENT SUGGESTED OPTIMIZATIONS
   - Position compression (int16 instead of float64)
   - Delta encoding for updates
   - Critical packet prioritization
   - Heartbeat to detect disconnections

3. ADD CLIENT-SIDE PREDICTION
   To further improve responsiveness, implement:
   - Local movement prediction
   - Reconciliation with server state
   - Interpolation to smooth corrections

4. TEST WITH DIFFERENT NETWORK CONDITIONS
   - Simulate 0-20% loss
   - Test with 20-200ms latencies
   - Validate behavior under congestion

5. CONSIDER AUXILIARY TCP CONNECTION
   For future non-real-time features:
   - Text chat
   - File transfer
   - Logs and statistics

================================================================================
12. APPENDICES
================================================================================

12.1 GLOSSARY
--------------------------------------------------------------------------------

RTT (Round-Trip Time):
    Round-trip time of a packet between client and server

Head-of-Line Blocking:
    Phenomenon where a lost packet blocks reception of subsequent packets

Jitter:
    Variation in latency over time

Delta Encoding:
    Technique of encoding differences rather than complete values

ECS (Entity-Component-System):
    Architecture where game objects are composed of entities and components

Idempotence:
    Property of an operation that can be repeated without undesired effects

Client-Side Prediction:
    Technique where client anticipates results of its actions

Reconciliation:
    Correction of client state to match authoritative server state

12.2 CALCULATION FORMULAS
--------------------------------------------------------------------------------

THEORETICAL BANDWIDTH:

    Bandwidth = (Packet_Size + Overhead) × Frequency × Number_Clients

Example for UDP:
    BW = (388 + 109) × 60 × 4
    BW = 497 × 60 × 4
    BW = 119,280 bytes/s
    BW ≈ 954 kbit/s (for 4 clients)

TOTAL LATENCY:

    Latency_UDP = Network_Latency

    Latency_TCP = Network_Latency + Retransmission_Time + Buffering_Delay
    
    With packet loss:
        Retransmission_Time = RTT × Number_Attempts

INPUT LAG:

    Input_Lag = 2 × Latency + Server_Processing_Time

Example UDP (30ms latency):
    Input_Lag = 2 × 30 + 5 = 65ms

Example TCP (100ms latency):
    Input_Lag = 2 × 100 + 5 = 205ms

12.3 ADDITIONAL RESOURCES
--------------------------------------------------------------------------------

DOCUMENTATION:

- RFC 768: User Datagram Protocol (UDP)
  https://datatracker.ietf.org/doc/html/rfc768

- RFC 793: Transmission Control Protocol (TCP)
  https://datatracker.ietf.org/doc/html/rfc793

- RFC 2119: Key Words for Use in RFCs
  https://datatracker.ietf.org/doc/html/rfc2119

ARTICLES AND TUTORIALS:

- "Quake 3 Networking Model" - John Carmack
  Description of Quake 3's network protocol

- "Fast-Paced Multiplayer" - Gabriel Gambetta
  Series of articles on real-time game networking

- "Gaffer On Games" - Glenn Fiedler
  Collection of technical articles on game networking

- "1500 Archers on a 28.8" - Age of Empires Networking
  Optimization techniques for RTS games

TESTING TOOLS:

- NetEm (Network Emulator): Network condition simulation
- Wireshark: Network packet analysis
- iperf: Bandwidth and latency measurement
- clumsy: Packet loss simulation on Windows

12.4 CRITICAL CODE EXAMPLES
--------------------------------------------------------------------------------

LOST PACKET DETECTION:

    class PacketTracker {
        uint32_t last_sequence = 0;
        uint32_t packets_received = 0;
        uint32_t packets_lost = 0;

        void processPacket(uint32_t sequence) {
            if (sequence > last_sequence + 1) {
                // Missing packets detected
                packets_lost += (sequence - last_sequence - 1);
            }
            last_sequence = sequence;
            packets_received++;
        }

        float getLossRate() {
            return (float)packets_lost / (packets_received + packets_lost);
        }
    };

CRITICAL EVENT RESENDING:

    class ReliableEventSender {
        struct PendingEvent {
            uint32_t event_id;
            std::string event_name;
            std::vector<uint8_t> data;
            int retry_count;
            std::chrono::time_point last_send;
        };

        std::unordered_map<uint32_t, PendingEvent> pending;

        void sendCriticalEvent(const std::string& name, 
                              const std::vector<uint8_t>& data) {
            uint32_t id = generateEventId();
            
            PendingEvent event;
            event.event_id = id;
            event.event_name = name;
            event.data = data;
            event.retry_count = 0;
            event.last_send = std::chrono::steady_clock::now();
            
            pending[id] = event;
            sendEventPacket(id, name, data);
        }

        void onConfirmation(uint32_t event_id) {
            pending.erase(event_id);
        }

        void update() {
            auto now = std::chrono::steady_clock::now();
            
            for (auto& [id, event] : pending) {
                auto elapsed = std::chrono::duration_cast<
                    std::chrono::milliseconds>(now - event.last_send);
                
                if (elapsed.count() > 100 && event.retry_count < 5) {
                    // Retry after 100ms
                    sendEventPacket(id, event.event_name, event.data);
                    event.last_send = now;
                    event.retry_count++;
                }
            }
        }
    };

INTERPOLATION FOR SMOOTHING:

    class PositionInterpolator {
        struct PositionSnapshot {
            Vector2 position;
            std::chrono::time_point timestamp;
        };

        std::deque<PositionSnapshot> snapshots;
        const int INTERPOLATION_DELAY_MS = 100;

        void addSnapshot(Vector2 pos) {
            PositionSnapshot snap;
            snap.position = pos;
            snap.timestamp = std::chrono::steady_clock::now();
            snapshots.push_back(snap);

            // Keep only last 10 snapshots
            if (snapshots.size() > 10) {
                snapshots.pop_front();
            }
        }

        Vector2 getInterpolatedPosition() {
            auto now = std::chrono::steady_clock::now();
            auto target_time = now - 
                std::chrono::milliseconds(INTERPOLATION_DELAY_MS);

            // Find two snapshots framing target_time
            for (size_t i = 0; i < snapshots.size() - 1; i++) {
                if (snapshots[i].timestamp <= target_time &&
                    snapshots[i + 1].timestamp >= target_time) {
                    
                    // Linear interpolation
                    auto t1 = snapshots[i].timestamp;
                    auto t2 = snapshots[i + 1].timestamp;
                    auto duration = std::chrono::duration_cast<
                        std::chrono::milliseconds>(t2 - t1).count();
                    auto elapsed = std::chrono::duration_cast<
                        std::chrono::milliseconds>(target_time - t1).count();
                    
                    float alpha = (float)elapsed / duration;
                    
                    return lerp(snapshots[i].position, 
                              snapshots[i + 1].position, 
                              alpha);
                }
            }

            // Fallback: return last known position
            return snapshots.back().position;
        }
    };

================================================================================
13. FINAL CONCLUSION
================================================================================

This in-depth comparative study between TCP and UDP for the R-Type project 
irrefutably demonstrates that UDP is the optimal choice for this type of game.

KEY POINTS:

1. The RTCP protocol intelligently exploits UDP's advantages while compensating 
   for its limitations through targeted application-level mechanisms.

2. The 50-70% latency reduction compared to TCP makes the difference between 
   a smooth and responsive gaming experience, and a frustrating and unplayable 
   game.

3. The ECS architecture of the protocol is naturally compatible with UDP's 
   stateless nature, allowing partial and redundant updates.

4. Selective reliability management allows performance optimization where it 
   really matters, without the systematic overhead of TCP.

5. Theoretical tests and real industry examples (Quake, Source, Unreal) confirm 
   that UDP is the de facto standard for real-time action games.

VERDICT:

The choice of UDP for R-Type is not only justified, but it is the ONLY viable 
choice to deliver the expected gaming experience. TCP would have led to freezes, 
unpredictable lag, and a degraded user experience.

The RTCP protocol as specified represents an excellent foundation for a 
performant and enjoyable multiplayer game.

================================================================================
REFERENCES
================================================================================

[RFC768]   Postel, J., "User Datagram Protocol", STD 6, RFC 768, August 1980.

[RFC793]   Postel, J., "Transmission Control Protocol", STD 7, RFC 793, 
           September 1981.

[RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate Requirement 
           Levels", BCP 14, RFC 2119, March 1997.

[RFC3629]  Yergeau, F., "UTF-8, a transformation format of ISO 10646", 
           STD 63, RFC 3629, November 2003.

[IEEE754]  IEEE, "IEEE Standard for Floating-Point Arithmetic", 
           IEEE 754-2008, August 2008.

[QUAKE3]   Carmack, J., "Quake III Arena Networking Model", id Software, 1999.

[SOURCE]   Valve Corporation, "Source Multiplayer Networking", Valve Developer 
           Community, 2004.

[GAFFER]   Fiedler, G., "Networking for Game Programmers", Gaffer On Games, 
           2010-2015.

[AOE]      Isensee, P., "1500 Archers on a 28.8: Network Programming in 
           Age of Empires", GDC, 2001.

================================================================================

Document prepared for R-Type Project - EPITECH 2025
Version: 1.0
Date: December 2025

Authors: Idriss DUPOISOT - EPITECH student - Promo 2028
Contact: idriss.dupoisot@epitech.eu
