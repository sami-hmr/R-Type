# R-Type Multiplayer Co-op UDP Protocol Specification

The protocol is in big-endian.

Table of types:

- string: A byte (8 bits) list that start
with the nb of elements (32-bit signed integer)
- list<type>: 32 bits (4 bytes) signed integer corresponding to the number of <type> to be interpreted


## 1. Connectionless Packets

Connectionless packets are identified by a magic sequence of 0x67676767 at the end.
[MAGIC_SEQUENCE] is a 4 bytes integer changing for each version that guarantee integrity of tha package.

### 1.1 Connectionless Packet Structure

<!-- Magic=0x67676767:32;Command:32 -->

Magic=0x67676767:32
Command:variable
End of Packet:8

### 1.2 Client-to-Server Connectionless Commands

All connectionless commands follow the format:

```
[MAGIC_SEQUENCE] <command> <arg1> <arg2> ... 0x67676767
```

Arguments are sent in binary format.

**getinfo**: Request basic server information (=> 0x01 : 8 bits)

```
[MAGIC_SEQUENCE] 0x01 0x67676767
```

Server responds with infoResponse.

**getstatus**: Request detailed server status including connected players (=> 0x02 : 8 bits)

```
[MAGIC_SEQUENCE] 0x02 0x67676767
```

Server responds with statusResponse.

**getchallenge**: Request a challenge token for connection authentication (=> 0x03 : 8 bits)

```
[MAGIC_SEQUENCE] 0x03 0x67676767
```

Server responds with challengeResponse containing a 32-bits challenge number.

**connect**: Initiate connection with challenge response and player information (=> 0x04 : 8 bits)

```
[MAGIC_SEQUENCE] 0x04 <challenge> <player_name> 0x67676767
```

Arguments:

- challenge: 32-bits integer (from challengeResponse) (4-bytes)
- player_name: string (cf. Table of types | Beginning of the documentation)

Example: `[MAGIC_SEQUENCE] 0x04 2847561 toto 0x67676767`

Server responds with connectResponse if successful.

### 1.3 Server-to-Client Connectionless Responses

All connectionless commands follow the format:

```
[MAGIC_SEQUENCE] <command> <arg1> <arg2> ... 0x67676767
```

Arguments are sent in binary format.

**infoResponse**: Basic server information response (=> 0x05 : 8 bits)

```
[MAGIC_SEQUENCE] 0x05 <value1> <value2>... 0x67676767
```

Required keys:

- game: Game name : string
- placesleft: Number of places left for the clients : 32-bits signed integer (4 bytes)

Example: `[MAGIC_SEQUENCE] 0x05 game placesleft 0x67676767`

**statusResponse**: Detailed status response with player list (=> 0x06 : 8 bits)

```
[MAGIC_SEQUENCE] 0x06 <server_info> <player1_info> <player2_info> ... 0x67676767
```

Format:

- server_info: Same key-value pairs as infoResponse
- player_info entries: list<player_info>

player_info format:

- name: Player name (max 256-bits) (= 32-bytes)
- ping: Ping in milliseconds (32-bits integer) (= 4-bytes)

Example: `[MAGIC_SEQUENCE] 0x06 game placesleft player1 40 player2 300 0x67676767`

**challengeResponse**: Challenge token for connection authentication (=> 0x07 : 8 bits)

```
[MAGIC_SEQUENCE] 0x07 <challenge_number>
```

Argument:

- challenge_number: 32-bits unsigned integer

The challenge number is a cryptographically random value generated by the server. Valid range: 1 to 4 294 967 295.

Example: `[MAGIC_SEQUENCE] 0x07 2847561 0x67676767`

**connectResponse**: Connection acknowledgment with client ID (=> 0x08 : 8 bits)

```
[MAGIC_SEQUENCE] 0x08 <client_id> <server_id> 0x67676767
```

Arguments:

- client_id: Player slot assigned to this client (8-bits integer 0-3)
- server_id: Unique server instance identifier (32-bits unsigned integer)


After receiving this, the client transitions to connected mode and expects srv_gamestate.

Example: `[MAGIC_SEQUENCE] 0x08 0 19283746 0x67676767`

**disconnectResponse**: Refusal of client's connection (=> 0x09 : 8 bits)

```
[MAGIC_SEQUENCE] 0x09 <error_message>
```

Argument:

- error_message: Reason why the server refused to let the client connect (256-bits) (32-bytes)

Example: `[MAGIC_SEQUENCE] 0x09 "protocol version mismatched" 0x67676767`

## 2. Connected Packets

All connected packets use binary format and include reliability mechanisms for critical messages.

### 2.0 Reliability and Acknowledgment Mechanism

Connected packets implement selective reliability on top of UDP. While snapshots are sent unreliably (packet loss is acceptable), commands must be reliably delivered.

**Reliable Acknowledge Field:**

The `reliable_acknowledge` field in server-to-client packets tells the client: "I received all your cli_command messages up to sequence number X". This allows the client to stop retransmitting acknowledged commands.

**How It Works:**

1. Client sends `cli_command` with sequence number N
2. Server receives the command and processes it
3. Server includes `reliable_acknowledge = N` in next packet
4. Client sees the acknowledgment and stops retransmitting that command

**Retransmission Strategy:**

For `srv_command` and `cli_command` messages:

- **Server-to-Client Commands:**
  - Retransmit every 200ms if not acknowledged
  - Maximum 5 retries (1 second total timeout)
  - After 5 failed retries, consider client disconnected
- **Client-to-Server Commands:**
  - Retransmit every 200ms if not acknowledged
  - Maximum 10 retries (2 seconds total timeout)
  - After 10 failed retries, consider server disconnected
  - Client gets more retries because server is typically more stable

- **Disconnect Messages (srv_disconnect):**
  - Send 3 times with 100ms intervals
  - No acknowledgment required
  - Multiple rapid sends increase delivery probability

**Why 200ms:**

- Good balance between responsiveness and network efficiency
- Works well even with 100-150ms network latency
- Not too fast (avoids spam), not too slow (user notices delay)

**Example Flow:**

```
Time  Client                          Server
0ms   Send cli_command seq=5 ------->
                                      Receive seq=5
50ms                     <--------    Send packet with reliable_ack=5
      Receive ack=5
      Stop retransmitting seq=5
```

**Example with Packet Loss:**

```
Time  Client                          Server
0ms   Send cli_command seq=6 ----X    (packet lost)
200ms Send cli_command seq=6 ------->
                                      Receive seq=6
250ms                     <--------    Send packet with reliable_ack=6
      Receive ack=6
      Stop retransmitting seq=6
```

### 2.1 Server-to-Client Packet Structure

All server-to-client packets begin with a 32-bits sequence number in little-endian format. If this sequence equals 0x67676767, the packet is connectionless (see section 1). Otherwise, the packet follows the connected format below.

PACKETS are always smaller than 2048 (eof and header included) otherwise the package is considered fragmented, another package with the same sequence will be sent until end of content byte is 1.

**Header:**

Fields:

- Sequence Number (32 bits): Incrementing packet sequence (starts at 1, wraps at 2^32)
- Reliable Acknowledge (32 bits): Highest cli_command sequence number received from this client
- End of content (8 bits): (0/1), cf previous warning about packet size

The Reliable Acknowledge field tells the client which commands have been successfully received. The client can stop retransmitting any cli_command with sequence <= Reliable Acknowledge.

Following the header, the packet contains one server operation messages.

**Server Operations:**

Server must send the first srv_snapshot immediately after connectResponse.

##### **srv_event (opcode 1):**

Sends an event from server to client.
Fields:

- Opcode=1:8
- EventString:string
- EventData:byte-list

##### **srv_snapshot (opcode 2):**

Transmits a game state snapshot entity updates. Snapshots are sent at regular intervals.
They contain multiple gs_... until the gs_oef

Fields:

- Opcode=2:8
- Server_Time:32
- Delta_Frame:8

**gs_entity_remove** (opcode 1)

- Entity_Number:32

**gs_entity_update/init** (opcode 2)

- Entity_Number:32
- Components of said entity in this format:
- - component_string_id:variable
- - component_data:component_size

Must end with **gs_oef** (8 bits: 0x69696969)

**Delta Compression:**

When Delta Frame > 0, only components that have changed since the referenced snapshot are transmitted. The client must maintain a history of the last 32 snapshots to support delta decompression.

If the client does not have the referenced snapshot (packet loss), it should:

1. Request a full snapshot via cli_acknowledge with special flag
2. Continue rendering using last known good state
3. Extrapolate entity positions based on last known velocities

##### **srv_disconnect (opcode 4):**

Notifies client of disconnection with reason. After receiving this, the client should close the connection and return to the main menu.

Fields:

- Opcode=4:8
- Reason:string

Common disconnect reasons:

- "Server shutting down": Normal server shutdown
- "Kicked by admin": Player was kicked
- "Timeout": Client stopped responding
- "Protocol version mismatch": Client using wrong protocol version
- "Server full": No available player slots
- "Duplicate connection": Player already connected from another address

The server should send srv_disconnect at least 3 times with 100ms intervals to ensure receipt, then close the socket. No acknowledgment is required - multiple rapid transmissions increase probability of delivery even with packet loss.

##### **srv_end (0x6767676767):**

Marks the end of server operations in the packet. All server packets must end with this opcode.

Fields:

- Opcode=0:8

No additional data follows. The packet ends immediately after this opcode.

### 2.2 Client-to-Server Packet Structure

All client-to-server packets begin with a 32-bits sequence number in little-endian format. If this sequence equals 0x67676767, the packet is connectionless (see section 1). Otherwise, the packet follows the connected format below.

**Header:**

Fields:

- Sequence_Number:32
- Server_ID:32
- Server_Message_Sequence:32
- Server_Command_Sequence:32

The Server Command Sequence field acknowledges srv_command messages. When the server sees this field increment, it knows that command was received and stops retransmitting it.

Following the header, the packet contains one or more client operation messages, each terminated by a cli_end operation (opcode 0).

**Client Operations:**

##### **cli_command (opcode 1):**

>[TODO]: Need to figure more specific commands the client could send

Sends a reliable command from client to server. Commands are acknowledged via reliable_acknowledge field and retransmitted if lost.

Fields:

- Opcode=1:8
- Command_Sequence:32
- Command:variable

Command format: `<command_opcode>;<arg1>;<arg2>;...`

Arguments are separated by semicolons.

Standard client commands:

**chat**: Send chat message

- Format: `chat;<message_text>`
- Example: `chat;Great teamwork!`
- Max message length: 256 characters

**disconnect**: Graceful disconnect request

- Format: `disconnect`
- No arguments
- Server should respond with srv_disconnect acknowledgment

Commands use the reliable acknowledgment mechanism:

- Client tracks each command by its Command Sequence number
- Client includes the highest received srv_command sequence in the Server Command Sequence field
- Server sees this acknowledgment and stops retransmitting that command
- Client retransmits unacknowledged cli_command messages every 200ms
- Maximum 10 retries (2 seconds timeout)
- After 10 failed retries, client considers server disconnected
- Client gets more retries than server because clients typically have less stable networks

##### **cli_move (opcode 2):**

>[TOFIX]: not really sure what is the best way to process inputs yet

Transmits player input commands. Multiple input samples can be included in a single packet for redundancy against packet loss.
Fields:

- Opcode=2:8
- Command_Count:8

Each input command in the sequence:

Fields:

- Server*Time*Î”:8
- Input_Mask:8
- Input_Bits:variable

Input mask bits (each corresponds to a 1-bit input flag if set):

- Bit 0 (0x01): Input 1 (application-defined)
- Bit 1 (0x02): Input 2 (application-defined)
- Bit 2 (0x04): Input 3 (application-defined)
- Bit 3 (0x08): Input 4 (application-defined)
- Bit 4 (0x10): Input 5 (application-defined)
- Bit 5 (0x20): Input 6 (application-defined)
- Bit 6 (0x40): Input 7 (application-defined)
- Bit 7 (0x80): Input 8 (application-defined)

The meaning of each input bit is defined by the game application. Common mappings include directional movement (up, down, left, right) and action buttons (primary fire, secondary fire, special ability, etc.).

**Redundancy Strategy:**
Clients should send the current input plus 2-3 previous inputs (Command Count = 3-4) to handle packet loss. Server deduplicates by tracking last processed Server Time Delta per client.

##### **cli_acknowledge (opcode 3):**

Acknowledges receipt of a server snapshot. Used for reliability tracking and packet loss statistics.

Fields:

- Opcode=3:8
- Snapshot_Sequence:32

Clients should send cli_acknowledge for every received snapshot to help server track:

- Round-trip time (RTT) for lag compensation
- Packet loss rate for adaptive quality adjustment
- Client responsiveness for timeout detection

Server uses acknowledgments to:

- Calculate average RTT per client (exponential moving average)
- Detect packet loss patterns
- Adjust snapshot send rate if network conditions degrade
- Determine appropriate Delta Frame values

If client misses multiple consecutive snapshots (>5), it should send cli_acknowledge with sequence 0 to request a full snapshot (Delta Frame = 0) in the next transmission.

##### **cli_end (opcode 0x67676767):**

Marks the end of client operations in the packet. All client packets must end with this opcode.

Fields:

- Opcode (8 bits): Always 0x67676767

No additional data follows. The packet ends immediately after this opcode.
