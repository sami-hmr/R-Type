# R-Type Multiplayer Co-op UDP Protocol Specification

This document describes the wire protocol for R-Type multiplayer communication. All implementations (regardless of programming language) must follow this specification to ensure interoperability.

## Protocol Overview

- **Transport**: UDP (User Datagram Protocol)
- **Byte Order**: Big-endian (network byte order) for all multi-byte values
- **Character Encoding**: UTF-8 for all text strings
- **Max Packet Size**: 2048 bytes (including headers and EOF marker)

### Quick Reference - Common Data Types

| Type | Wire Format | Description |
|------|-------------|-------------|
| **String** | `[length:32][bytes:variable]` | Length-prefixed UTF-8 string |
| **List** | `[count:32][elements:variable]` | Count-prefixed sequence |
| **Optional** | `[has_value:8][value:variable?]` | Boolean flag + optional value |
| **Boolean** | `[value:8]` | 0x00 = false, 0x01 = true |


## 1. Connectionless Packets

Connectionless packets are used for server discovery and connection establishment before entering connected mode.

### Protocol Constants

- **MAGIC_SEQUENCE**: `0x93 0x27 0x48 0x43` (4 bytes, identifies protocol version)
- **PROTOCOL_EOF**: `0x42 0x67 0xAB 0x01` (4 bytes, marks end of packet)

### 1.1 Connectionless Packet Structure

```
[MAGIC_SEQUENCE:32] [Command:8] [Arguments:variable] [PROTOCOL_EOF:32]
```

All connectionless packets follow this structure:
- **MAGIC_SEQUENCE**: 4 bytes - Protocol version identifier (0x93 0x27 0x48 0x43 in big-endian)
- **Command**: 1 byte opcode
- **Arguments**: Variable length command-specific data
- **PROTOCOL_EOF**: 4 bytes - End-of-packet marker (0x42 0x67 0xAB 0x01)

### 1.2 Client-to-Server Connectionless Commands

All connectionless commands follow the format:

```
[MAGIC_SEQUENCE] <command:8> <arguments> [PROTOCOL_EOF]
```

Arguments are sent in binary format.

**getinfo**: Request basic server information (=> 0x01 : 8 bits)

```
[MAGIC_SEQUENCE] 0x01 [PROTOCOL_EOF]
```

Server responds with infoResponse.

**getstatus**: Request detailed server status including connected players (=> 0x02 : 8 bits)

```
[MAGIC_SEQUENCE] 0x02 [PROTOCOL_EOF]
```

Server responds with statusResponse (same as infoResponse but includes player list).

**getchallenge**: Request a challenge token for connection authentication (=> 0x03 : 8 bits)

```
[MAGIC_SEQUENCE] 0x03 [PROTOCOL_EOF]
```

Server responds with challengeResponse containing a 32-bit challenge number.

**connect**: Initiate connection with challenge response and player information (=> 0x04 : 8 bits)

```
[MAGIC_SEQUENCE] 0x04 <challenge:32> <player_name:string> [PROTOCOL_EOF]
```

Arguments:

- challenge: 32-bit integer (from challengeResponse) (4 bytes)
- player_name: string (null-terminated with length prefix)

Example: `[MAGIC_SEQUENCE] 0x04 [challenge:4 bytes] [name_length:4][name bytes] [PROTOCOL_EOF]`

Server responds with connectResponse if successful.

### 1.3 Server-to-Client Connectionless Responses

All connectionless responses follow the format:

```
[MAGIC_SEQUENCE] <command:8> <arguments> [PROTOCOL_EOF]
```

Arguments are sent in binary format.

**infoResponse**: Basic server information response (=> 0x05 : 8 bits)

```
[MAGIC_SEQUENCE] 0x05 <hostname> <mapname> <gametype:8> <max_players:32> <protocol_version:8> [PROTOCOL_EOF]
```

Fields:
- hostname: String (max 64 bytes) - Server display name
- mapname: String (max 32 bytes) - Current map/level name
- gametype: 8-bit integer (0x01 = SOLO, 0x02 = COOP)
- max_players: 32-bit integer - Maximum number of players (typically 4)
- protocol_version: 8-bit integer - Current protocol version (currently 1)

Example: `[MAGIC_SEQUENCE] 0x05 "R-Type Server" "level1" 0x02 0x00000004 0x01 [PROTOCOL_EOF]`

**statusResponse**: Detailed status response with player list (=> 0x06 : 8 bits)

```
[MAGIC_SEQUENCE] 0x06 <server_info> <player_list> [PROTOCOL_EOF]
```

Format:
- server_info: Same as infoResponse (hostname, mapname, gametype, max_players, protocol_version)
- player_list: For each connected player:
  - score: 32-bit integer
  - ping: 8-bit integer (milliseconds)
  - player_name: String

Example: `[MAGIC_SEQUENCE] 0x06 [server_info] [score1:32][ping1:8][name1] [score2:32][ping2:8][name2] ... [PROTOCOL_EOF]`

**challengeResponse**: Challenge token for connection authentication (=> 0x07 : 8 bits)

```
[MAGIC_SEQUENCE] 0x07 <challenge_number:32> [PROTOCOL_EOF]
```

Argument:
- challenge_number: 32-bit unsigned integer

The challenge number is a cryptographically random value generated by the server. Valid range: 1 to 4,294,967,295.

Example: `[MAGIC_SEQUENCE] 0x07 0x002B7F39 [PROTOCOL_EOF]`

**connectResponse**: Connection acknowledgment with client ID (=> 0x08 : 8 bits)

```
[MAGIC_SEQUENCE] 0x08 <client_id:8> <server_id:32> [PROTOCOL_EOF]
```

Arguments:
- client_id: Player slot assigned to this client (8-bit integer 0-3)
- server_id: Unique server instance identifier (32-bit unsigned integer)

After receiving this, the client transitions to connected mode and can start sending/receiving connected packets.

Example: `[MAGIC_SEQUENCE] 0x08 0x00 0x0125AE62 [PROTOCOL_EOF]`

**disconnectResponse**: Refusal of client's connection or server-initiated disconnect (=> 0x09 : 8 bits)

```
[MAGIC_SEQUENCE] 0x09 <error_message:string> [PROTOCOL_EOF]
```

Argument:
- error_message: Reason for disconnection (string, max 32 bytes)

Common disconnect reasons:
- "Server shutting down"
- "Server full"  
- "Protocol version mismatch"
- "Invalid challenge"

Example: `[MAGIC_SEQUENCE] 0x09 "Server full" [PROTOCOL_EOF]`

## 2. Connected Packets

All connected packets use binary format. Connected mode is entered after receiving a connectResponse.

### 2.1 Packet Fragmentation

Connected packets are always smaller than 2048 bytes (including EOF and header). If a message exceeds this size, it is fragmented across multiple packets with the same sequence number. The `end_of_content` flag indicates whether this is the final fragment (true) or more fragments follow (false).

### 2.2 Server-to-Client Packet Structure

All server-to-client connected packets follow this structure:

**Header:**

```
[MAGIC_SEQUENCE:32] [Sequence_Number:32] [Acknowledge:32] [End_Of_Content:8] [Payload:variable] [PROTOCOL_EOF:32]
```

Fields:
- **MAGIC_SEQUENCE**: 4 bytes (0x93 0x27 0x48 0x43)
- **Sequence_Number**: 32-bit unsigned integer (big-endian) - Incrementing packet sequence (starts at 0)
- **Acknowledge**: 32-bit unsigned integer (big-endian) - Currently unused (set to 0)
- **End_Of_Content**: 8-bit boolean - 1 if last fragment, 0 if more fragments follow
- **Payload**: Variable length - Contains one or more server operations
- **PROTOCOL_EOF**: 4 bytes (0x42 0x67 0xAB 0x01)

**Server Operations:**

##### **srv_sendcomp (opcode 0x02):**

Sends component data for a specific entity.

Format:
```
[0x02] [entity_id:64] [component_id:string] [component_data:variable]
```

Fields:
- **Opcode**: 0x02
- **Entity_ID**: 64-bit unsigned integer (big-endian) - Entity identifier
- **Component_ID**: String - Component type identifier (e.g., "Position", "Velocity")
- **Component_Data**: Byte array - Serialized component data (format depends on component type)

##### **srv_sendevent (opcode 0x01):**

Sends an event from server to client.

Format:
```
[0x01] [event_id:string] [event_data:variable]
```

Fields:
- **Opcode**: 0x01
- **Event_ID**: String - Event type identifier (e.g., "PlayerDeath", "LevelComplete")
- **Event_Data**: Byte array - Serialized event data (format depends on event type)

### 2.3 Client-to-Server Packet Structure

All client-to-server connected packets follow this structure:

**Header:**

```
[MAGIC_SEQUENCE:32] [Sequence_Number:32] [Acknowledge:32] [End_Of_Content:8] [Payload:variable] [PROTOCOL_EOF:32]
```

Fields:
- **MAGIC_SEQUENCE**: 4 bytes (0x93 0x27 0x48 0x43)
- **Sequence_Number**: 32-bit unsigned integer (big-endian) - Incrementing packet sequence (starts at 0)
- **Acknowledge**: 32-bit unsigned integer (big-endian) - Currently unused (set to 0)
- **End_Of_Content**: 8-bit boolean - 1 if last fragment, 0 if more fragments follow
- **Payload**: Variable length - Contains client operation
- **PROTOCOL_EOF**: 4 bytes (0x42 0x67 0xAB 0x01)

**Client Operations:**

##### **cli_sendevent (opcode 0x01):**

Sends an event from client to server (e.g., player actions, game events).

Format:
```
[0x01] [event_id:string] [event_data:variable]
```

Fields:
- **Opcode**: 0x01
- **Event_ID**: String - Event type identifier (e.g., "PlayerMove", "FireWeapon")
- **Event_Data**: Byte array - Serialized event data (format depends on event type)

## 3. Data Types and Wire Format

All multi-byte values use **big-endian** byte order (most significant byte first).

### 3.1 Primitive Types

**Unsigned Integers:**
| Type | Size | Example Value | Wire Bytes (hex) |
|------|------|---------------|------------------|
| 8-bit | 1 byte | 255 | `0xFF` |
| 16-bit | 2 bytes | 1000 | `0x03 0xE8` |
| 32-bit | 4 bytes | 65536 | `0x00 0x01 0x00 0x00` |
| 64-bit | 8 bytes | 1000000 | `0x00 0x00 0x00 0x00 0x00 0x0F 0x42 0x40` |

**Signed Integers:**
Signed integers use two's complement representation in big-endian byte order.

| Type | Size | Example Value | Wire Bytes (hex) |
|------|------|---------------|------------------|
| 8-bit | 1 byte | -1 | `0xFF` |
| 16-bit | 2 bytes | -1000 | `0xFC 0x18` |
| 32-bit | 4 bytes | -65536 | `0xFF 0xFF 0x00 0x00` |
| 64-bit | 8 bytes | -1000000 | `0xFF 0xFF 0xFF 0xFF 0xFF 0xF0 0xBD 0xC0` |

**Floating Point:**
| Type | Size | Format | Byte Order |
|------|------|--------|------------|
| 32-bit float | 4 bytes | IEEE 754 single precision | Big-endian |
| 64-bit double | 8 bytes | IEEE 754 double precision | Big-endian |

**Boolean:**
| Value | Wire Byte |
|-------|-----------|
| false | `0x00` |
| true | `0x01` |

### 3.2 String Format

Strings are UTF-8 encoded with a length prefix:

```
[length:32] [utf8_bytes:variable]
```

- **length**: 32-bit unsigned integer (big-endian) - Number of bytes in the string
- **utf8_bytes**: UTF-8 encoded characters (NOT null-terminated)

**Example**: String "Hello"
```
Offset  Hex                                      ASCII
0x0000  00 00 00 05 48 65 6C 6C 6F               ....Hello
        [  length  ] [H][e][l][l][o]
```

**Example**: Empty string ""
```
Offset  Hex
0x0000  00 00 00 00
        [  length=0]
```

### 3.3 List/Array Format

Lists are serialized with a count prefix followed by elements:

```
[count:32] [element1] [element2] ... [elementN]
```

- **count**: 32-bit unsigned integer (big-endian) - Number of elements in the list
- **elements**: Each element serialized according to its type

**Example**: List of three 32-bit integers [10, 20, 30]
```
Offset  Hex
0x0000  00 00 00 03  00 00 00 0A  00 00 00 14  00 00 00 1E
        [  count=3] [    10    ] [    20    ] [    30    ]
```

**Example**: List of two strings ["foo", "bar"]
```
Offset  Hex
0x0000  00 00 00 02                              ....        (count=2)
0x0004  00 00 00 03 66 6F 6F                     ....foo     (length=3, "foo")
0x000B  00 00 00 03 62 61 72                     ....bar     (length=3, "bar")
```

### 3.4 Optional Value Format

Optional values use a presence flag followed by the value (if present):

```
[has_value:8] [value:variable (if has_value == 1)]
```

- **has_value**: 1 byte - `0x00` = no value, `0x01` = value present
- **value**: Only present if has_value is `0x01`, serialized according to its type

**Example**: Optional 32-bit integer with value 42
```
Offset  Hex
0x0000  01 00 00 00 2A
        [Y][    42    ]
```

**Example**: Optional 32-bit integer with no value
```
Offset  Hex
0x0000  00
        [N]
```

### 3.5 Map/Dictionary Format

Maps are serialized as lists of key-value pairs:

```
[count:32] [key1][value1] [key2][value2] ... [keyN][valueN]
```

- **count**: 32-bit unsigned integer (big-endian) - Number of key-value pairs
- **pairs**: Each key and value serialized according to their types

**Example**: Map {"age": 25, "score": 1000} (string keys, 32-bit integer values)
```
Offset  Hex
0x0000  00 00 00 02                              ....        (count=2 pairs)
0x0004  00 00 00 03 61 67 65                     ....age     (key "age")
0x000B  00 00 00 19                              ....        (value 25)
0x000F  00 00 00 05 73 63 6F 72 65               ....score   (key "score")
0x0019  00 00 00 03 E8                           ....        (value 1000)
```

### 3.6 Component and Event Data

Component and event data are application-specific byte sequences. The structure of these byte sequences depends on the component or event type identified by the Component_ID or Event_ID string.

Implementations should define their own serialization formats for each component and event type. Common examples:

**Position Component** (hypothetical):
```
Component_ID: "Position"
Data format: [x:64 (double)] [y:64 (double)]
```

**Velocity Component** (hypothetical):
```
Component_ID: "Velocity"
Data format: [dx:64 (double)] [dy:64 (double)]
```

**PlayerMove Event** (hypothetical):
```
Event_ID: "PlayerMove"
Data format: [direction:8] [speed:32 (float)]
```

## 4. Connection Flow

1. Client sends `getchallenge` (connectionless)
2. Server responds with `challengeResponse` containing random challenge number
3. Client sends `connect` with challenge and player name (connectionless)
4. Server validates challenge and responds with `connectResponse` containing client_id and server_id
5. Client transitions to connected mode
6. Server sends initial game state via `srv_sendcomp` and `srv_sendevent` packets
7. Client and server exchange connected packets for game synchronization

## 5. Protocol Notes

### 5.1 No Reliability Layer

The protocol does NOT include automatic retransmission or acknowledgment of lost packets. Applications must handle packet loss:
- Accept loss of component updates (next update will overwrite)
- Implement application-level acknowledgment for critical events if needed
- Use redundant packets for important state transitions

### 5.2 Packet Fragmentation

Messages larger than 2048 bytes (including all headers and EOF marker) are fragmented:
1. Split message into chunks
2. Send each chunk with the SAME sequence number
3. Set `End_Of_Content` to 0 for all fragments except the last
4. Set `End_Of_Content` to 1 for the final fragment
5. Receiver reassembles all fragments with matching sequence numbers

### 5.3 Entity-Component System

The protocol supports component-based entity architecture:
- **Entities**: Identified by unique 64-bit unsigned integers
- **Components**: Identified by string names (e.g., "Position", "Velocity", "Health")
- Component data format is application-specific and not defined by this protocol

### 5.4 Event System

Events carry application-specific game state changes:
- **Events**: Identified by string names (e.g., "PlayerDeath", "EnemySpawn")
- Event data format is application-specific and not defined by this protocol
- Events flow bidirectionally (client→server and server→client)

## 6. Protocol Constants

| Constant | Value | Description |
|----------|-------|-------------|
| **MAGIC_SEQUENCE** | `0x93 0x27 0x48 0x43` | Protocol version identifier |
| **PROTOCOL_EOF** | `0x42 0x67 0xAB 0x01` | End-of-packet marker |
| **MAX_PLAYERS** | 4 | Maximum number of simultaneous players |
| **MAX_PACKET_SIZE** | 2048 bytes | Maximum packet size (including headers) |
| **PROTOCOL_VERSION** | 1 | Current protocol version number |
| **MAX_PLAYERNAME** | 32 bytes | Maximum player name length |
| **MAX_HOSTNAME** | 64 bytes | Maximum server hostname length |
| **MAX_MAPNAME** | 32 bytes | Maximum map name length |

## 7. Implementation Reference

The reference implementation is written in C++ and can be found in:
- `include/plugin/Byte.hpp` - Serialization utilities
- `src/plugins/Byte.cpp` - Serialization implementation
- `plugins/client_network/` - Client network plugin
- `plugins/server_network/` - Server network plugin
- `include/NetworkCommun.hpp` - Protocol constants and structures

Implementers in other languages should follow this specification, not the C++ implementation details.
