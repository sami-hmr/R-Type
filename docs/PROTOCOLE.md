# R-Type Multiplayer Co-op UDP Protocol Specification

This document describes the wire protocol for R-Type multiplayer communication. All implementations (regardless of programming language) must follow this specification to ensure interoperability.

## Protocol Overview

- **Transport**: UDP (User Datagram Protocol)
- **Byte Order**: Big-endian (network byte order) for all multi-byte values
- **Character Encoding**: UTF-8 for all text strings
- **Max Packet Size**: 2048 bytes (including headers and EOF marker)
- **Compression**: zlib (DEFLATE algorithm)
- **Encryption**: XOR cipher with key = 67
- **Reliability**: Custom acknowledgment system with retransmission

### Quick Reference - Common Data Types

| Type | Wire Format | Description |
|------|-------------|-------------|
| **String** | `[length:32][bytes:variable]` | Length-prefixed UTF-8 string |
| **List** | `[count:32][elements:variable]` | Count-prefixed sequence |
| **Optional** | `[has_value:8][value:variable?]` | Boolean flag + optional value |
| **Boolean** | `[value:8]` | 0x00 = false, 0x01 = true |


## 1. Connectionless Packets

Connectionless packets are used for server discovery and connection establishment before entering connected mode.

### Protocol Constants

- **MAGIC_SEQUENCE**: `0x436482793` (defined as `__VERSION_MAGIC_SEQUENCE__` in code)
- **PROTOCOL_EOF**: `0x42 0x67 0xAB 0x01` (4 bytes, marks end of packet)
- **XOR_KEY**: 67 (used for packet encryption)
- **BUFFER_SIZE**: 9092 bytes

### 1.1 Connectionless Packet Structure

```
[MAGIC_SEQUENCE:32] [Command:8] [Arguments:variable] [PROTOCOL_EOF:32]
```

All connectionless packets follow this structure:
- **MAGIC_SEQUENCE**: 4 bytes - Protocol version identifier (0x93 0x27 0x48 0x43 in big-endian)
- **Command**: 1 byte opcode
- **Arguments**: Variable length command-specific data
- **PROTOCOL_EOF**: 4 bytes - End-of-packet marker (0x42 0x67 0xAB 0x01)

### 1.2 Client-to-Server Connectionless Commands

All connectionless commands follow the format:

```
[MAGIC_SEQUENCE] <command:8> <arguments> [PROTOCOL_EOF]
```

Arguments are sent in binary format.

**getinfo**: Request basic server information (=> 0x01 : 8 bits)

```
[MAGIC_SEQUENCE] 0x01 [PROTOCOL_EOF]
```

Server responds with infoResponse.

**getstatus**: Request detailed server status including connected players (=> 0x02 : 8 bits)

```
[MAGIC_SEQUENCE] 0x02 [PROTOCOL_EOF]
```

Server responds with statusResponse (same as infoResponse but includes player list).

**getchallenge**: Request a challenge token for connection authentication (=> 0x03 : 8 bits)

```
[MAGIC_SEQUENCE] 0x03 [PROTOCOL_EOF]
```

Server responds with challengeResponse containing a 32-bit challenge number.

**connect**: Initiate connection with challenge response and player information (=> 0x04 : 8 bits)

```
[MAGIC_SEQUENCE] 0x04 <challenge:32> <player_name:string> [PROTOCOL_EOF]
```

Arguments:

- challenge: 32-bit integer (from challengeResponse) (4 bytes)
- player_name: string (null-terminated with length prefix)

Example: `[MAGIC_SEQUENCE] 0x04 [challenge:4 bytes] [name_length:4][name bytes] [PROTOCOL_EOF]`

Server responds with connectResponse if successful.

### 1.3 Server-to-Client Connectionless Responses

All connectionless responses follow the format:

```
[MAGIC_SEQUENCE] <command:8> <arguments> [PROTOCOL_EOF]
```

Arguments are sent in binary format.

**infoResponse**: Basic server information response (=> 0x05 : 8 bits)

```
[MAGIC_SEQUENCE] 0x05 <hostname> <mapname> <gametype:8> <max_players:32> <protocol_version:8> [PROTOCOL_EOF]
```

Fields:
- hostname: String (max 64 bytes) - Server display name
- mapname: String (max 32 bytes) - Current map/level name
- gametype: 8-bit integer (0x01 = SOLO, 0x02 = COOP)
- max_players: 32-bit integer - Maximum number of players (typically 4)
- protocol_version: 8-bit integer - Current protocol version (currently 1)

Example: `[MAGIC_SEQUENCE] 0x05 "R-Type Server" "level1" 0x02 0x00000004 0x01 [PROTOCOL_EOF]`

**statusResponse**: Detailed status response with player list (=> 0x06 : 8 bits)

```
[MAGIC_SEQUENCE] 0x06 <server_info> <player_list> [PROTOCOL_EOF]
```

Format:
- server_info: Same as infoResponse (hostname, mapname, gametype, max_players, protocol_version)
- player_list: For each connected player:
  - score: 32-bit integer
  - ping: 8-bit integer (milliseconds)
  - player_name: String

Example: `[MAGIC_SEQUENCE] 0x06 [server_info] [score1:32][ping1:8][name1] [score2:32][ping2:8][name2] ... [PROTOCOL_EOF]`

**challengeResponse**: Challenge token for connection authentication (=> 0x07 : 8 bits)

```
[MAGIC_SEQUENCE] 0x07 <challenge_number:32> [PROTOCOL_EOF]
```

Argument:
- challenge_number: 32-bit unsigned integer

The challenge number is a cryptographically random value generated by the server. Valid range: 1 to 4,294,967,295.

Example: `[MAGIC_SEQUENCE] 0x07 0x002B7F39 [PROTOCOL_EOF]`

**connectResponse**: Connection acknowledgment with client ID (=> 0x08 : 8 bits)

```
[MAGIC_SEQUENCE] 0x08 <client_id:8> <server_id:32> [PROTOCOL_EOF]
```

Arguments:
- client_id: Player slot assigned to this client (8-bit integer 0-3)
- server_id: Unique server instance identifier (32-bit unsigned integer)

After receiving this, the client transitions to connected mode and can start sending/receiving connected packets.

Example: `[MAGIC_SEQUENCE] 0x08 0x00 0x0125AE62 [PROTOCOL_EOF]`

**disconnectResponse**: Refusal of client's connection or server-initiated disconnect (=> 0x09 : 8 bits)

```
[MAGIC_SEQUENCE] 0x09 <error_message:string> [PROTOCOL_EOF]
```

Argument:
- error_message: Reason for disconnection (string, max 32 bytes)

Common disconnect reasons:
- "Server shutting down"
- "Server full"  
- "Protocol version mismatch"
- "Invalid challenge"

Example: `[MAGIC_SEQUENCE] 0x09 "Server full" [PROTOCOL_EOF]`

## 2. Connected Packets

All connected packets use binary format. Connected mode is entered after receiving a connectResponse.

### 2.1 Packet Compression and Encryption

**Before transmission:**
1. Payload is compressed using zlib (DEFLATE algorithm)
2. Entire packet (including headers) is encrypted using XOR cipher with key = 67

**On reception:**
1. Entire packet is decrypted using XOR cipher with key = 67
2. Payload is decompressed using zlib (inflate)

### 2.2 Packet Fragmentation

If a compressed message exceeds 2048 bytes (including headers and EOF), it is fragmented:
- Each fragment has an incrementing sequence number
- The `end_of_content` flag is `0` for all fragments except the last
- The final fragment has `end_of_content = 1`
- Receiver accumulates fragments in a buffer until `end_of_content = 1`, then decompresses

### 2.3 Reliability Layer

The implementation includes an acknowledgment system for reliable delivery:

**Sequence Numbers:**
- Both client and server maintain independent 32-bit sequence counters
- Sequence starts at 1 and increments for each sent packet

**Acknowledge Field:**
- Contains the highest in-order sequence number successfully received
- Allows sender to free buffers for acknowledged packets

**Retransmission:**
- Unacknowledged packets are buffered in `_waiting_for_aprouval` map
- Retransmission timeout: 100ms (0.1 second)
- Lost packets are detected via sequence number gaps
- Receiver requests retransmission by including lost sequence numbers in heartbeat

**Priority Flag:**
- Packets with `prioritary = true` bypass the acknowledgment manager
- Sent and processed immediately without buffering

### 2.4 Server-to-Client Packet Structure

All server-to-client connected packets follow this structure:

**Header:**

```
[MAGIC_SEQUENCE:32] [Sequence_Number:32] [Acknowledge:32] [End_Of_Content:8] [Payload:variable] [PROTOCOL_EOF:32]
```

Fields:
- **MAGIC_SEQUENCE**: 4 bytes (0x436482793 in actual implementation)
- **Sequence_Number**: 32-bit unsigned integer (big-endian) - Incrementing packet sequence (starts at 1)
- **Acknowledge**: 32-bit unsigned integer (big-endian) - Highest in-order sequence received
- **End_Of_Content**: 8-bit boolean - 1 if last fragment, 0 if more fragments follow
- **Payload**: Variable length - Contains one or more server operations
- **PROTOCOL_EOF**: 4 bytes (0x42 0x67 0xAB 0x01)

**Server Operations:**

##### **srv_sendevent (opcode 0x01):**

Sends an event from server to client.

Format:
```
[0x01] [event_id:string] [event_data:variable]
```

Fields:
- **Opcode**: 0x01
- **Event_ID**: String - Event type identifier (e.g., "PlayerDeath", "LevelComplete")
- **Event_Data**: Byte array - Serialized event data (format depends on event type)

##### **srv_sendcomp (opcode 0x02):**

Sends component data for a specific entity.

Format:
```
[0x02] [entity_id:64] [component_id:string] [component_data:variable]
```

Fields:
- **Opcode**: 0x02
- **Entity_ID**: 64-bit unsigned integer (big-endian) - Entity identifier
- **Component_ID**: String - Component type identifier (e.g., "Position", "Velocity")
- **Component_Data**: Byte array - Serialized component data (format depends on component type)

##### **srv_sendheartbeat (opcode 0x03):**

Heartbeat packet containing timing and lost packet information.

Format:
```
[0x03] [timestamp:64] [lost_packages_count:32] [lost_seq1:64] [lost_seq2:64] ...
```

Fields:
- **Opcode**: 0x03
- **Timestamp**: 64-bit unsigned integer - Send timestamp for latency calculation
- **Lost_Packages_Count**: 32-bit unsigned integer - Number of lost sequence numbers
- **Lost_Sequences**: List of 64-bit sequence numbers that need retransmission

##### **srv_ffgonext (opcode 0x04):**

Reset acknowledgment state (used for crash recovery).

Format:
```
[0x04] [next_sequence:64]
```

Fields:
- **Opcode**: 0x04
- **Next_Sequence**: 64-bit unsigned integer - New sequence number to skip to

### 2.5 Client-to-Server Packet Structure

All client-to-server connected packets follow this structure:

**Header:**

```
[MAGIC_SEQUENCE:32] [Sequence_Number:32] [Acknowledge:32] [End_Of_Content:8] [Payload:variable] [PROTOCOL_EOF:32]
```

Fields:
- **MAGIC_SEQUENCE**: 4 bytes (0x436482793 in actual implementation)
- **Sequence_Number**: 32-bit unsigned integer (big-endian) - Incrementing packet sequence (starts at 1)
- **Acknowledge**: 32-bit unsigned integer (big-endian) - Highest in-order sequence received
- **End_Of_Content**: 8-bit boolean - 1 if last fragment, 0 if more fragments follow
- **Payload**: Variable length - Contains client operation
- **PROTOCOL_EOF**: 4 bytes (0x42 0x67 0xAB 0x01)

**Client Operations:**

##### **cli_sendevent (opcode 0x01):**

Sends an event from client to server (e.g., player actions, game events).

Format:
```
[0x01] [event_id:string] [event_data:variable]
```

Fields:
- **Opcode**: 0x01
- **Event_ID**: String - Event type identifier (e.g., "PlayerMove", "FireWeapon")
- **Event_Data**: Byte array - Serialized event data (format depends on event type)

## 3. Data Types and Wire Format

All multi-byte values use **big-endian** byte order (most significant byte first).

### 3.1 Primitive Types

**Unsigned Integers:**
| Type | Size | Example Value | Wire Bytes (hex) |
|------|------|---------------|------------------|
| 8-bit | 1 byte | 255 | `0xFF` |
| 16-bit | 2 bytes | 1000 | `0x03 0xE8` |
| 32-bit | 4 bytes | 65536 | `0x00 0x01 0x00 0x00` |
| 64-bit | 8 bytes | 1000000 | `0x00 0x00 0x00 0x00 0x00 0x0F 0x42 0x40` |

**Signed Integers:**
Signed integers use two's complement representation in big-endian byte order.

| Type | Size | Example Value | Wire Bytes (hex) |
|------|------|---------------|------------------|
| 8-bit | 1 byte | -1 | `0xFF` |
| 16-bit | 2 bytes | -1000 | `0xFC 0x18` |
| 32-bit | 4 bytes | -65536 | `0xFF 0xFF 0x00 0x00` |
| 64-bit | 8 bytes | -1000000 | `0xFF 0xFF 0xFF 0xFF 0xFF 0xF0 0xBD 0xC0` |

**Floating Point:**
| Type | Size | Format | Byte Order |
|------|------|--------|------------|
| 32-bit float | 4 bytes | IEEE 754 single precision | Big-endian |
| 64-bit double | 8 bytes | IEEE 754 double precision | Big-endian |

**Boolean:**
| Value | Wire Byte |
|-------|-----------|
| false | `0x00` |
| true | `0x01` |

### 3.2 String Format

Strings are UTF-8 encoded with a length prefix:

```
[length:32] [utf8_bytes:variable]
```

- **length**: 32-bit unsigned integer (big-endian) - Number of bytes in the string
- **utf8_bytes**: UTF-8 encoded characters (NOT null-terminated)

**Example**: String "Hello"
```
Offset  Hex                                      ASCII
0x0000  00 00 00 05 48 65 6C 6C 6F               ....Hello
        [  length  ] [H][e][l][l][o]
```

**Example**: Empty string ""
```
Offset  Hex
0x0000  00 00 00 00
        [  length=0]
```

### 3.3 List/Array Format

Lists are serialized with a count prefix followed by elements:

```
[count:32] [element1] [element2] ... [elementN]
```

- **count**: 32-bit unsigned integer (big-endian) - Number of elements in the list
- **elements**: Each element serialized according to its type

**Example**: List of three 32-bit integers [10, 20, 30]
```
Offset  Hex
0x0000  00 00 00 03  00 00 00 0A  00 00 00 14  00 00 00 1E
        [  count=3] [    10    ] [    20    ] [    30    ]
```

**Example**: List of two strings ["foo", "bar"]
```
Offset  Hex
0x0000  00 00 00 02                              ....        (count=2)
0x0004  00 00 00 03 66 6F 6F                     ....foo     (length=3, "foo")
0x000B  00 00 00 03 62 61 72                     ....bar     (length=3, "bar")
```

### 3.4 Optional Value Format

Optional values use a presence flag followed by the value (if present):

```
[has_value:8] [value:variable (if has_value == 1)]
```

- **has_value**: 1 byte - `0x00` = no value, `0x01` = value present
- **value**: Only present if has_value is `0x01`, serialized according to its type

**Example**: Optional 32-bit integer with value 42
```
Offset  Hex
0x0000  01 00 00 00 2A
        [Y][    42    ]
```

**Example**: Optional 32-bit integer with no value
```
Offset  Hex
0x0000  00
        [N]
```

### 3.5 Map/Dictionary Format

Maps are serialized as lists of key-value pairs:

```
[count:32] [key1][value1] [key2][value2] ... [keyN][valueN]
```

- **count**: 32-bit unsigned integer (big-endian) - Number of key-value pairs
- **pairs**: Each key and value serialized according to their types

**Example**: Map {"age": 25, "score": 1000} (string keys, 32-bit integer values)
```
Offset  Hex
0x0000  00 00 00 02                              ....        (count=2 pairs)
0x0004  00 00 00 03 61 67 65                     ....age     (key "age")
0x000B  00 00 00 19                              ....        (value 25)
0x000F  00 00 00 05 73 63 6F 72 65               ....score   (key "score")
0x0019  00 00 00 03 E8                           ....        (value 1000)
```

### 3.6 Component and Event Data

Component and event data are application-specific byte sequences. The structure of these byte sequences depends on the component or event type identified by the Component_ID or Event_ID string.

Implementations should define their own serialization formats for each component and event type. Common examples:

**Position Component** (hypothetical):
```
Component_ID: "Position"
Data format: [x:64 (double)] [y:64 (double)]
```

**Velocity Component** (hypothetical):
```
Component_ID: "Velocity"
Data format: [dx:64 (double)] [dy:64 (double)]
```

**PlayerMove Event** (hypothetical):
```
Event_ID: "PlayerMove"
Data format: [direction:8] [speed:32 (float)]
```

## 4. Connection Flow

1. Client sends `getchallenge` (connectionless)
2. Server responds with `challengeResponse` containing random challenge number
3. Client sends `connect` with challenge and player name (connectionless)
4. Server validates challenge and responds with `connectResponse` containing client_id and server_id
5. Client transitions to connected mode
6. Server sends initial game state via `srv_sendcomp` and `srv_sendevent` packets
7. Client and server exchange connected packets for game synchronization

## 5. Implementation Details

### 5.1 Heartbeat System

The implementation uses heartbeats for connection monitoring and lost packet recovery:

**Frequency**: 15 Hz (66.67ms interval)
- Defined as: `hearthbeat_delta = 1000000000 / 15` nanoseconds

**Heartbeat Contents:**
- Timestamp for RTT calculation
- List of lost packet sequence numbers for retransmission requests

**Network Status Reports:**
- Generated every 1 second (1,000,000,000 nanoseconds)
- Contains latency, packet loss statistics

### 5.2 Timeout Values

**Client Disconnection Timeout**: 1.5 seconds
- Client considers server disconnected after 1,500,000,000 nanoseconds without response

**Server Client Timeout**: 5 seconds
- Server disconnects idle clients after 5,000,000,000 nanoseconds

**Retransmission Cooldown**: 100ms
- Unacknowledged packets are retransmitted after 100,000 microseconds

**Lost Packet Request Cooldown**: 200ms
- Gap detection re-requests after 200,000 microseconds

**Reset Delta**: 2 seconds
- Time between state transfer resets: 2,000,000,000 nanoseconds

**Reset Max Count**: 20
- Maximum number of resets before disconnection

### 5.3 Buffer Limits

**Circular Buffer**: 9092 bytes
- Used for packet reception and boundary detection

**Max Packet Division**: Calculated based on compressed payload size

### 5.4 State Transfer (Crash Recovery)

When a client sends malformed packets or gets out of sync:
1. Server sends `FFGONEXT` command with new sequence number
2. Client resets its acknowledgment manager to the new sequence
3. Server emits `StateTransfer` event
4. All current component states are sent to the client
5. Client emits `ResetClient` event to clear local entities

## 6. Protocol Constants

| Constant | Value | Description |
|----------|-------|-------------|
| **MAGIC_SEQUENCE** | `0x436482793` | Protocol version identifier (`__VERSION_MAGIC_SEQUENCE__`) |
| **PROTOCOL_EOF** | `0x42 0x67 0xAB 0x01` | End-of-packet marker |
| **XOR_KEY** | 67 | Encryption key for XOR cipher |
| **BUFFER_SIZE** | 9092 bytes | Circular buffer size |
| **MAX_PLAYERS** | 4 | Maximum simultaneous players (client ID is uint8_t, actual limit 256) |
| **MAX_PACKET_SIZE** | 2048 bytes | Maximum packet size (including headers) |
| **PROTOCOL_VERSION** | 1 | Current protocol version number |
| **MAX_PLAYERNAME** | 32 bytes | Maximum player name length |
| **MAX_HOSTNAME** | 64 bytes | Maximum server hostname length |
| **MAX_MAPNAME** | 32 bytes | Maximum map name length |
| **HEARTBEAT_INTERVAL** | 66.67ms (15 Hz) | Time between heartbeat packets |
| **HEARTBEAT_DELTA** | 66,666,667 ns | Heartbeat interval in nanoseconds (1000000000/15) |
| **RAPPORT_COOLDOWN** | 1000ms | Network status report interval |
| **DISCONNECTION_TIMEOUT** | 1500ms | Client-side disconnect timeout |
| **CLIENT_DISCONNECT_TIMEOUT** | 5000ms | Server-side client timeout |
| **SENT_DELTA** | 100ms | Retransmission cooldown (100,000 μs) |
| **ASK_COOLDOWN** | 200ms | Lost packet request cooldown (200,000 μs) |
| **RESET_DELTA** | 2000ms | State transfer reset interval |
| **RESET_MAX_COUNT** | 20 | Maximum resets before disconnection |

## 7. Implementation Reference

The reference implementation is written in C++ and can be found in:
- `include/network/` - Network interface headers
  - `Server.hpp`, `Client.hpp` - Main network interfaces
  - `PacketCompresser.hpp` - Compression and encryption
  - `AcknowledgeManager.hpp` - Reliability layer
  - `HttpClient.hpp` - HTTP client for API
- `src/network/` - Network implementation
  - `server/` - Server implementation (receive_loop, send_comp, send_event)
  - `client/` - Client implementation (receive_loop, send_evt, send_hearthbeat)
  - `PacketCompresser.cpp` - zlib compression and XOR encryption
  - `AcknowledgeManager.cpp` - Packet buffering and retransmission
  - `HttpClient.cpp` - Asynchronous HTTP requests
- `include/plugin/Byte.hpp` - Serialization utilities
- `src/plugins/Byte.cpp` - Type serialization implementation

**Key Implementation Features:**
- **Threading**: Client and server use separate threads for receive, send, and heartbeat
- **Compression**: zlib DEFLATE with 20,000-byte buffer
- **Encryption**: Simple XOR cipher applied to entire packet
- **Reliability**: Per-client AcknowledgeManager on server, single manager on client
- **Buffering**: Circular buffer for efficient packet extraction
- **Fragmentation**: Automatic fragmentation with sequence-based reassembly

Implementers in other languages should follow this specification, not the C++ implementation details.
